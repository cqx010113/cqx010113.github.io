<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js知识点</title>
      <link href="/2022/07/29/js-mian-shi-ti/"/>
      <url>/2022/07/29/js-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="1-原型、构造函数、实例"><a href="#1-原型、构造函数、实例" class="headerlink" title="1.原型、构造函数、实例"></a>1.原型、构造函数、实例</h2><ol><li><p>原型：一个对象，用于实现对象的属性继承，可以理解为对象的父亲，在FireFox和Chrome中，每个JavaScript对象都可以通过obj.______proto______进行访问。</p></li><li><p>构造函数：可通过new创建一个新对象的函数。</p></li><li><p>实例：通过构造函数和new创建出的对象便是实例，实例通过______proto______指向原型，通过constructor指向构造函数。</p><pre class=" language-javascript"><code class="language-javascript">实例<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> 原型原型<span class="token punctuation">.</span>constructor <span class="token operator">===</span> 构造函数构造函数<span class="token punctuation">.</span>prototype <span class="token operator">===</span> 原型<span class="token comment" spellcheck="true">// 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线</span><span class="token comment" spellcheck="true">// 例如: </span><span class="token comment" spellcheck="true">// const o = new Object()</span><span class="token comment" spellcheck="true">// o.constructor === Object   --> true</span><span class="token comment" spellcheck="true">// o.__proto__ = null;</span><span class="token comment" spellcheck="true">// o.constructor === Object   --> false</span><span class="token comment" spellcheck="true">// 注意: 其实实例上并不是真正有 constructor 这个指针，它其实是从原型链上获取的</span><span class="token comment" spellcheck="true">//      instance.hasOwnProperty('constructor') === false   (感谢 刘博海 Brian 童鞋🥳)</span>实例<span class="token punctuation">.</span>constructor <span class="token operator">===</span> 构造函数</code></pre><p>![](img&#x2F;截屏2021-12-09 下午3.32.41.png)</p></li></ol><h2 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2.原型链"></a>2.原型链</h2><p>原型链由原型对象组成，每个对象都有______proto______属性，指向了创建该对象的构造函数的原型，______proto______将对象连接起来组成了原型链，是一个用来实现继承和共享属性的有限的对象链。</p><ol><li>属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还没找到，则输出undefined。</li><li>属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用：<code>x.prototype.x = 2;</code>，但是这样会导致所有继承于该对象的实例的属性发生改变。</li></ol><h2 id="3-执行上下文"><a href="#3-执行上下文" class="headerlink" title="3.执行上下文"></a>3.执行上下文</h2><p>执行上下文可以简单理解为一个对象</p><ul><li>它包含三个部分，分别为：变量对象（VO）、作用链域（词法作用域）、this指向</li><li>他分成三个类型，分别为：全局执行上下文、函数执行上下文、eval执行上下文</li></ul><p>代码执行过程主要为：</p><ol><li>创建全局上下文(global EC)</li><li>全局执行上下文(caller)逐行自上而下执行，遇到函数时，函数执行上下文(callee)被<code>push</code>到执行栈顶层</li><li>函数执行上下文被激活，成为active EC，开始执行函数中的代码，caller被挂起</li><li>函数执行完后，callee被<code>pop</code>移除出执行栈，控制权交还全局上下文(caller)，继续执行</li></ol><h2 id="4-变量对象"><a href="#4-变量对象" class="headerlink" title="4.变量对象"></a>4.变量对象</h2><p>变量对象是执行上下文中的一部分，可以抽象为一种数据作用域，其实也可以理解成一个简单的对象，存储着该执行上下文中的所有变量和函数声明(不包含函数表达式)。</p><p>活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。</p><h2 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5.作用域"></a>5.作用域</h2><p>执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的变量和声明的作用范围。可分为块级作用域和函数作用域<br>特性：</p><ul><li>声明提前：一个声明在函数体内都是可见的，函数优先于变量</li><li>非匿名自执行函数，函数变量为只读状态，无法修改</li></ul><h2 id="6-作用链域"><a href="#6-作用链域" class="headerlink" title="6.作用链域"></a>6.作用链域</h2><p>我们可以在执行上下文中访问到父级甚至全局的变量，这要归功于作用链域。作用链域可以理解为一组对象列表，包含父级和自身的变量对象，因此我们能通过作用域链访问到父级里声明的变量或函数。</p><p>作用链域由两部分组成：</p><ol><li><code>[[scope]]</code>属性：指向父级变量对象和作用域链，也就是包含了父级的<code>[[scope]]</code>和AO</li><li>AO：自身活动对象</li></ol><p>如此，<code>[[scope]]</code>包含了<code>[[scope]]</code>，便自上而下形成了一条作用链域</p><h2 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7.闭包"></a>7.闭包</h2><p>闭包属于一种特殊的作用域，称为静态作用域，它的定义可以理解为：在父函数被销毁的情况下，返回出的子函数的<code>[[scope]]</code>中仍然保留着父级的单变量对象和作用链域，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</p><p>闭包经典问题：多个子函数的<code>[[scope]]</code>都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。</p><p>解决：</p><ul><li>变量可以通过函数传参的形式传入，避免使用默认的<code>[[scope]]</code>向上查找。</li><li>使用setTimeOut包裹，通过第三个参数传入</li><li>使用块级作用域，让变量成为自己上下文的属性，避免共享</li></ul><h2 id="8-script的引入方式"><a href="#8-script的引入方式" class="headerlink" title="8.script的引入方式"></a>8.script的引入方式</h2><ol><li>html静态<code>&lt;script&gt;</code>引入</li><li>js动态插入<code>&lt;script&gt;</code></li><li><code>&lt;script defer&gt;</code>延迟加载，元素解析完成后执行</li><li><code>&lt;script async&gt;</code>异步加载，但执行时会阻塞元素渲染</li></ol><h2 id="9-对象的拷贝"><a href="#9-对象的拷贝" class="headerlink" title="9.对象的拷贝"></a>9.对象的拷贝</h2><p>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，<strong>修改时原对象也会受到影响</strong></p><ul><li><code>Object.assign</code></li><li>展开运算符(…)</li></ul><p>深拷贝: 完全拷贝一个新对象，<strong>修改时原对象不再受到任何影响</strong></p><ul><li><pre class=" language-javascript"><code class="language-javascript">JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>: 性能最快</p><ul><li>具有循环引用的对象时，报错</li><li>当值为函数、<code>undefined</code>、或<code>symbol</code>时，无法拷贝</li></ul></li><li><p>递归进行逐一赋值</p></li></ul><h2 id="10-new运算符的执行过程"><a href="#10-new运算符的执行过程" class="headerlink" title="10.new运算符的执行过程"></a>10.new运算符的执行过程</h2><ol><li>新生成一个对象</li><li>链接到原型<code>obj.______proto______ = Con.prototype</code></li><li>绑定this：apply</li><li>返回新对象，如果构造函数有自己return时，则返回该值</li></ol><h2 id="11-instanceof原理"><a href="#11-instanceof原理" class="headerlink" title="11.instanceof原理"></a>11.instanceof原理</h2><p>能在实例的原型对象链中找到该构造函数的prototype属性所指向的原型对象，就返回true。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// __proto__: 代表原型对象链</span>instance<span class="token punctuation">.</span><span class="token punctuation">[</span>__proto__<span class="token operator">...</span><span class="token punctuation">]</span> <span class="token operator">===</span> instance<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span>prototype<span class="token comment" spellcheck="true">// return true</span></code></pre><h2 id="12-代码的复用"><a href="#12-代码的复用" class="headerlink" title="12.代码的复用"></a>12.代码的复用</h2><p>当发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式:</p><ul><li>函数封装</li><li>继承</li><li>复制<code>extend</code></li><li>混入<code>mixin</code></li><li>借用<code>apply/call</code></li></ul><h2 id="13-继承"><a href="#13-继承" class="headerlink" title="13.继承"></a>13.继承</h2><p>在js中，继承一般指的是原型链继承，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。</p><ul><li>&#x3D;&#x3D;<strong>最优化：圣杯模式</strong>&#x3D;&#x3D;</li><li>使用 ES6 的语法糖 <code>class / extends</code></li></ul><h2 id="14-类型转换"><a href="#14-类型转换" class="headerlink" title="14.类型转换"></a>14.类型转换</h2><p>JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:</p><ul><li>-、*、&#x2F;、% ：一律转换成数值后计算</li><li>+：<ul><li>数字 + 字符串 &#x3D; 字符串， 运算顺序是从左到右</li><li>数字 + 对象， 优先调用对象的<code>valueOf</code> -&gt; <code>toString</code></li><li>数字 + <code>boolean/null</code> -&gt; 数字</li><li>数字 + <code>undefined</code> -&gt; <code>NaN</code></li></ul></li><li><code>[1].toString() === &#39;1&#39;</code></li><li><code>&#123;&#125;.toString() === &#39;[object object]&#39;</code></li><li><code>NaN</code> !&#x3D;&#x3D; <code>NaN</code> 、<code>+undefined 为 NaN</code></li></ul><h2 id="15-类型判断"><a href="#15-类型判断" class="headerlink" title="15.类型判断"></a>15.类型判断</h2><p>判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p><ul><li>基本类型(<code>null</code>)：使用 <code>String(null)</code></li><li>基本类型(<code>string / number / boolean / undefined</code>) + <code>function</code>：直接使用 <code>typeof</code>即可</li><li>其余引用类型(<code>Array / Date / RegExp Error</code>)：调用<code>toString</code>后根据<code>[object XXX]</code>进行判断</li></ul><h2 id="16-模块化"><a href="#16-模块化" class="headerlink" title="16.模块化"></a>16.模块化</h2><p>模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 <strong>在浏览器中使用 ES6 的模块化支持，在 Node 中使用 commonjs 的模块化支持。</strong></p><ul><li>分类:<ul><li>es6: <code>import / export</code></li><li>commonjs: <code>require / module.exports / exports</code></li><li>amd: <code>require / defined</code></li></ul></li><li><code>require</code>与<code>import</code>的区别<ul><li><code>require</code>支持 <strong>动态导入</strong>，<code>import</code>不支持，正在提案 (babel 下可支持)</li><li><code>require</code>是 <strong>同步</strong> 导入，<code>import</code>属于 <strong>异步</strong> 导入</li><li><code>require</code>是 <strong>值拷贝</strong>，导出值变化不会影响导入值；<code>import</code>指向 <strong>内存地址</strong>，导入值会随导出值而变化</li></ul></li></ul><h2 id="17-防抖与节流"><a href="#17-防抖与节流" class="headerlink" title="17.防抖与节流"></a>17.防抖与节流</h2><p>防抖与节流函数是一种最常用的 <strong>高频触发优化方式</strong>，能对性能有较大的帮助。</p><ul><li>**防抖 (debounce)**：将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</li><li>**节流(throttle)**：每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者resize事件，通常每隔100~500ms执行一次即可。</li></ul><h2 id="18-函数执行改变this"><a href="#18-函数执行改变this" class="headerlink" title="18.函数执行改变this"></a>18.函数执行改变this</h2><p>由于js的设计原理，在函数中可以引用运行环境中的变量，因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是this。</p><p><a href="https://www.cnblogs.com/pssp/p/5216085.html">讲得很好的this指向</a></p><p>要明白this的指向，就要弄清楚函数的运行环境，也就是 是谁调用了函数。</p><p><code>obj.fn()</code> 便是obj调用了函数，既函数中<code>this === obj</code></p><p><code>fn()</code>在此处可以看作window.fn()，因此<code>this === window</code></p><p>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 <code>this</code> 的指向:</p><ul><li><code>call: fn.call(target, 1, 2)</code></li><li><code>apply: fn.apply(target, [1, 2])</code></li><li><code>bind: fn.bind(target)(1,2)</code></li></ul><p><a href="https://blog.csdn.net/hexinyu_1022/article/details/82795517">讲得很好的call、apply、bind博客1</a></p><h2 id="19"><a href="#19" class="headerlink" title="19."></a>19.</h2><h2 id="20-抽象语法树-Abstract-Syntax-Tree"><a href="#20-抽象语法树-Abstract-Syntax-Tree" class="headerlink" title="20.抽象语法树 (Abstract Syntax Tree)"></a>20.抽象语法树 (Abstract Syntax Tree)</h2><p>AST，是将代码逐字母解析成树状对象的形式。</p><p>这是语言之间的转换、代码语法检查、代码风格检查、代码格式化、代码高亮、代码错误提示、代码自动补全等等的基础</p><h2 id="21-函数柯里化"><a href="#21-函数柯里化" class="headerlink" title="21.函数柯里化"></a>21.函数柯里化</h2><p>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可以在不入侵函数的前提下，为函数预设通用参数，供多次重复调用。</p><h1 id="————————————————————————————"><a href="#————————————————————————————" class="headerlink" title="————————————————————————————"></a>————————————————————————————</h1><p>JS基础问题</p><h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h1><h3 id="1-数据类型-1"><a href="#1-数据类型-1" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p>JS 7种原始值：null、undefined、number、boolean、string、bigint、symbol</p><p>引用数据类型：Object(包括普通对象-Object、数组对象-Array、正则对象-RegExp、日期对象-Date、数学函数-Math、函数对象-Function)</p><h3 id="2-函数参数传递问题"><a href="#2-函数参数传递问题" class="headerlink" title="2.函数参数传递问题"></a>2.函数参数传递问题</h3><img src="img/截屏2021-12-09 下午10.44.46.png" style="zoom: 50%;" /><p>因为函数参数在传递时一般是传递对象在堆中的内存地址，因此，在p1传递进test的其实是p1的地址，实际上只修改了p1.age，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。</p><h3 id="3-null是对象吗？为什么？"><a href="#3-null是对象吗？为什么？" class="headerlink" title="3.null是对象吗？为什么？"></a>3.null是对象吗？为什么？</h3><p>null不是对象，虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象然而 null 表示为全零，所以将它错误的判断为 object 。</p><h3 id="4-’1’-toString-为什么可以调用"><a href="#4-’1’-toString-为什么可以调用" class="headerlink" title="4.’1’.toString()为什么可以调用"></a>4.’1’.toString()为什么可以调用</h3><img src="img/截屏2021-12-09 下午10.54.11.png" style="zoom:50%;" /><h3 id="5-0-1-0-2为什么不等于0-3"><a href="#5-0-1-0-2为什么不等于0-3" class="headerlink" title="5.  0.1+0.2为什么不等于0.3"></a>5.  0.1+0.2为什么不等于0.3</h3><p>0.1和0.2在转换成二进制后会无限循环，由于标准位数的限制后面多余的位数会被截掉，此时就已经出现了精度的损失，相加后因浮点数小数位的限制而截断的二进制数字在转换为十进制就会变成0.30000000000000004。</p><h3 id="6-BigInt"><a href="#6-BigInt" class="headerlink" title="6.BigInt"></a>6.BigInt</h3><p><a href="%E7%9C%8BBigInt%E9%82%A3%E4%B8%80%E5%9D%97">https://juejin.cn/post/6844903974378668039#heading-4</a></p><h1 id="2-数据检测"><a href="#2-数据检测" class="headerlink" title="2.数据检测"></a>2.数据检测</h1><h3 id="1-typeof-是否能正确判断类型"><a href="#1-typeof-是否能正确判断类型" class="headerlink" title="1.typeof 是否能正确判断类型"></a>1.typeof 是否能正确判断类型</h3><p>对于原始类型来说，除了 null 都可以调用typeof显示正确的类型。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment" spellcheck="true">// 'number'</span><span class="token keyword">typeof</span> <span class="token string">'1'</span> <span class="token comment" spellcheck="true">// 'string'</span><span class="token keyword">typeof</span> undefined <span class="token comment" spellcheck="true">// 'undefined'</span><span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 'boolean'</span><span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'symbol'</span></code></pre><p>但对于引用数据类型，除了函数之外，都会显示”object”。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 'object'</span><span class="token keyword">typeof</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 'object'</span><span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log <span class="token comment" spellcheck="true">// 'function'</span></code></pre><p>因此采用typeof判断对象数据类型是不合适的，采用instanceof会更好，instanceof的原理是基于原型链的查询，只要处于原型链中，判断永远为true</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>p1 <span class="token keyword">instanceof</span> <span class="token class-name">Person</span> <span class="token comment" spellcheck="true">// true</span><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">'hello world'</span>str1 <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment" spellcheck="true">// false</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>str2 <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment" spellcheck="true">// true</span></code></pre><h3 id="2-instanceof能否判断基本数据类型"><a href="#2-instanceof能否判断基本数据类型" class="headerlink" title="2.instanceof能否判断基本数据类型"></a>2.instanceof能否判断基本数据类型</h3><h3 id="3-手动实现instanceof"><a href="#3-手动实现instanceof" class="headerlink" title="3.手动实现instanceof"></a>3.手动实现instanceof</h3><p>核心：原型链的向上查找功能</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myInstanceOf</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//判断是否基本数据类型，如果是则返回false</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> left <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span> left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//getPrototypeOf是Object对象自带的一个方法，能拿到参数的原型对象</span>  <span class="token keyword">let</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果查找到尽头还没有找到</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//找到相同的原型对象</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>proto <span class="token operator">==</span> right<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//顺着原型链往上</span>    proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//测试</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">,</span> String<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> String<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span></code></pre><h3 id="4-Object-is和-x3D-x3D-x3D-的区别"><a href="#4-Object-is和-x3D-x3D-x3D-的区别" class="headerlink" title="4.Object.is和&#x3D;&#x3D;&#x3D;的区别"></a>4.Object.is和&#x3D;&#x3D;&#x3D;的区别</h3><p>Object在严格等于的基础上修复了一些特殊情况下的失误，具体来说就是+0和-0，NaN和NaN。 源码如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">is</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> y<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//运行到1/x === 1/y的时候x和y都为0，但是1/+0 = +Infinity， 1/-0 = -Infinity, 是不一样的</span>    <span class="token keyword">return</span> x <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> y <span class="token operator">!==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token number">1</span> <span class="token operator">/</span> x <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">/</span> y<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//NaN===NaN是false,这是不对的，我们在这里做一个拦截，x !== x，那么一定是 NaN, y 同理</span>    <span class="token comment" spellcheck="true">//两个都是NaN的时候返回true</span>    <span class="token keyword">return</span> x <span class="token operator">!==</span> x <span class="token operator">&amp;&amp;</span> y <span class="token operator">!==</span> y<span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h1 id="3-数据类型转换"><a href="#3-数据类型转换" class="headerlink" title="3.数据类型转换"></a>3.数据类型转换</h1><h3 id="1-x3D-x3D-结果是什么？为什么？"><a href="#1-x3D-x3D-结果是什么？为什么？" class="headerlink" title="1.[] &#x3D;&#x3D; ![]结果是什么？为什么？"></a>1.[] &#x3D;&#x3D; ![]结果是什么？为什么？</h3><p>等号左右两边进行转换，[]转化为数字0，![]首先转化为布尔型，由于[]作为一个引用类型转换为布尔值true</p><p>因此&#x3D;&#x3D;左右两边分别为：0 &#x3D;&#x3D; false，false转换为数字0，结果为true</p><h3 id="2-JS中类型转换"><a href="#2-JS中类型转换" class="headerlink" title="2.JS中类型转换"></a>2.JS中类型转换</h3><p>JS中，类型转换只有三种：</p><ul><li>转换成数字</li><li>转换成布尔值</li><li>转换成字符串</li></ul><p>转换具体规则如下:</p><p>​“Boolean 转字符串”这行结果指的是 true 转字符串的例子</p><img src="img/img1.png" style="zoom:70%;" /><p>3.<code>==</code>与<code>===</code>区别</p><p><code>===</code>叫严格要求，不仅左右两边值要相等，类型也要相等，例如<code>&#39;1&#39;===1</code>的结果是false，因为一边是<code>string</code>，另一边是<code>number</code>。</p><p><code>==</code>不像<code>===</code>一样严格，对于一般情况，只要值相等，就返回true，但<code>==</code>还涉及一些类型转换，它的转换规则如下：</p><ul><li>两边的类型是否相同，相同的话就比较值的大小，例如<code>1==2</code>，返回false</li><li>判断的是否是null和undefined，是的话返回true</li><li>判断的类型是否是String和Number，是的话，就把String转为Number再进行比较</li><li>判断其中一方是否是Boolean，是的话就把Boolean转为Number再进行比较</li><li>如果一方是否为Object，且另一方为String、Number或Symbol，会将Object转换成字符串，再进行比较</li></ul><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">==</span> <span class="token string">"[object Object]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span></code></pre><h3 id="4-对象转原始类型是根据什么流程运行的"><a href="#4-对象转原始类型是根据什么流程运行的" class="headerlink" title="4.对象转原始类型是根据什么流程运行的"></a>4.对象转原始类型是根据什么流程运行的</h3><p>对象转原始数据类型，会调用内置的<code>ToPrimitive</code>函数，该函数逻辑如下：</p><ol><li>如果<code>Symbol.ToPrimitive()</code>，优先调用再返回；</li><li>调用<code>valueOf()</code>，如果转换为原始类型，则返回；</li><li>调用<code>toString()</code>，如果转换为原始类型，则返回</li><li>如果上述都没有返回原始类型，则报错</li></ol><h3 id="5-如何让if-a-x3D-x3D-1-amp-amp-a-x3D-x3D-2-条件成立？"><a href="#5-如何让if-a-x3D-x3D-1-amp-amp-a-x3D-x3D-2-条件成立？" class="headerlink" title="5.如何让if(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2)条件成立？"></a>5.如何让if(a &#x3D;&#x3D; 1 &amp;&amp; a &#x3D;&#x3D; 2)条件成立？</h3><h1 id="4-对闭包的理解"><a href="#4-对闭包的理解" class="headerlink" title="4.对闭包的理解"></a>4.对闭包的理解</h1><h3 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1.什么是闭包"></a>1.什么是闭包</h3><p>红宝书：闭包就是有权访问另一个函数作用域中的变量的函数。</p><p>MDN 对闭包的定义：闭包是指那些能够访问自由变量的函数。 （其中自由变量，指在函数中使用的，但既不是函数参数arguments也不是函数的局部变量的变量，其实就是另外一个函数作用域中的变量）</p><h3 id="2-闭包产生的原因"><a href="#2-闭包产生的原因" class="headerlink" title="2.闭包产生的原因"></a>2.闭包产生的原因</h3><p>首先要明白作用域链的概念：在ES5中只存在两种作用域，全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链，值得注意的是，每一个子函数都会拷贝上级的作用域，形成一个作用域的链条。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>  <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//3</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>在上述代码中，f1的作用域指向全局作用域(window)和它本身，而f2的作用域指向全局作用域(window)、f1、和它本身，而且作用域是从最底层向上找，直到找到全局作用域window为止，如果全局还没有的话就会报错。就这么简单一件事情！</p><p>闭包产生的本质就是，当前环境中存在指向父级作用域的引用。还是举上面的例子:</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端安全</title>
      <link href="/2022/07/29/qian-duan-an-quan/"/>
      <url>/2022/07/29/qian-duan-an-quan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-XSS攻击"><a href="#1-XSS攻击" class="headerlink" title="1.XSS攻击"></a>1.XSS攻击</h2><h4 id="什么是XSS攻击，能做什么"><a href="#什么是XSS攻击，能做什么" class="headerlink" title="什么是XSS攻击，能做什么"></a>什么是XSS攻击，能做什么</h4><p>对xss<a href="https://blog.csdn.net/yusimiao/article/details/94352459?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.nonecase">攻击的解释参考</a></p><p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p><p>XSS攻击：跨站脚本攻击Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击，通过注入恶意脚本，使之在用户浏览器上运行，然后利用这些恶意脚本，攻击者可以：</p><ul><li>获取页面数据</li><li>获取用户的敏感信息Cookie、SessionID</li><li>劫持前端逻辑</li><li>发送请求到攻击者自己的网站实现资料的盗取</li><li>偷取网站任意数据</li><li>偷取用户密码和登陆状态</li><li>改变按钮的逻辑</li></ul><h4 id="XSS-常见的注入方法："><a href="#XSS-常见的注入方法：" class="headerlink" title="XSS 常见的注入方法："></a>XSS 常见的注入方法：</h4><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 <code>javascript:</code> (伪协议)等可执行代码。</li></ul><h4 id="XSS攻击类型"><a href="#XSS攻击类型" class="headerlink" title="XSS攻击类型"></a>XSS攻击类型</h4><p>XSS攻击分为三种，分别为反射型、存储型和DOM-based型。</p><p>&#x3D;&#x3D;存储型XSS&#x3D;&#x3D;，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大。</p><p>eg：<strong>在评论的时候写script标签，这样数据就是存储在数据库中的，如果该页面要读取出这条有script标签的信息，那么将这个网址发给别人别人也会中招。</strong></p><ul><li>攻击者将恶意代码提交到目标网站数据库中</li><li>客户端最后从服务器得到的就是恶意代码，在浏览器执行的也是该恶意代码</li><li>恶意代码将用户数据发送至攻击者网站</li></ul><p>&#x3D;&#x3D;反射型XSS&#x3D;&#x3D;（有点像那种色情小广告，点进去你就没了）</p><p><strong>通过URL参数直接注入，一般是使用alert来探测站点是否防御，直接攻击的使用src来引入自己的脚本</strong></p><p>eg：<code>http://localhost:1521/?from=&lt;script&gt;alert(1)&lt;/script&gt;</code></p><ul><li>攻击者构建特殊URL，里面包含恶意代码</li><li>当用户打开此URL时，网站的服务端将恶意代码从中取出，并且<strong>拼接在HTML</strong>返回给浏览器（这应该属于后端渲染范围）</li><li>恶意代码被浏览器执行，然后将用户数据发送给攻击者网站</li></ul><p>&#x3D;&#x3D;DOM型XSS&#x3D;&#x3D;（感觉和反射型XSS很像，只不过这个是属于JavaScript的安全漏洞（浏览器的DOM解析），反射型XSS是属于服务端的安全漏洞），所以防范DOM型XSS是前端的责任</p><ul><li>同样的，攻击者构造特殊URL，其中包含恶意代码</li><li>用户打开后，浏览器解析，<strong>JavaScript取出URL</strong>然后执行</li><li>恶意代码被浏览器执行，然后将用户数据发送给攻击者网站</li></ul><h4 id="防范XSS"><a href="#防范XSS" class="headerlink" title="防范XSS"></a>防范XSS</h4><h6 id="常用的防范手段："><a href="#常用的防范手段：" class="headerlink" title="常用的防范手段："></a>常用的防范手段：</h6><ul><li><p><strong>httpOnly:</strong> 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。</p></li><li><p><strong>输入过滤:</strong> 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。</p></li><li><p>&#x3D;&#x3D;最普遍的做法：&#x3D;&#x3D;<strong>转义 HTML:</strong> 如果拼接HTML是必要的，就需要对于引号，尖括号，斜杠进行转义。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">escape</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&amp;/g</span><span class="token punctuation">,</span> <span class="token string">"&amp;amp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/&lt;/g</span><span class="token punctuation">,</span> <span class="token string">"&amp;lt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/>/g</span><span class="token punctuation">,</span> <span class="token string">"&amp;gt;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token string">"/g, "</span><span class="token operator">&amp;</span>quto<span class="token punctuation">;</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span>        str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/'/g</span><span class="token punctuation">,</span> <span class="token string">"&amp;#39;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/`/g</span><span class="token punctuation">,</span> <span class="token string">"&amp;#96;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/\//g</span><span class="token punctuation">,</span> <span class="token string">"&amp;#x2F;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> str<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><img src="../img/截屏2021-12-11 下午7.13.28.png" style="zoom:50%;" /><pre class=" language-javascript"><code class="language-javascript"><span class="token function">escape</span><span class="token punctuation">(</span><span class="token string">'&lt;script>alert(1)&lt;/script>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//&amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span></code></pre></li><li><p><strong>添加白名单</strong>：对于显示富文本来说，以上方法可能会将需要的格式也过滤掉，这时我们可以添加白名单的方式，其实也就是对匹配到的字段进行处理（使用黑名单也可以，但是黑名单要过滤的标签和标签属性太多了）</p><p>使用已经写好的xss组件<code>npm install xss</code>，使用第三方库xss指定白名单</p><p><a href="https://github.com/leizongmin/js-xss/blob/master/README.zh.md">xss具体文档</a></p><p><a href="https://jsxss.com/zh/index.html">不那么全面但是比较好打开的文档</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> xssFilter <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>html<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">;</span>     <span class="token keyword">var</span> xss <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'xss'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token function">xss</span><span class="token punctuation">(</span>html<span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        whiteList<span class="token punctuation">:</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//只允许img标签，该标签只允许有src属性</span>            img<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'src'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//只允许a标签，该标签只允许有href属性</span>            a<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'href'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>          <span class="token comment" spellcheck="true">//只允许font标签，该标签只允许有size、color属性</span>            font<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'size'</span><span class="token punctuation">,</span> <span class="token string">'color'</span><span class="token punctuation">]</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">//自定义匹配到不在白名单上的标签时的处理方法</span>        onIgnoreTag<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token string">''</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>html<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>除了XSS过滤工具，还有<strong>Sanitizer</strong>这个API，可以配置白名单，黑名单，但兼容性很差。</p></li></ul><h6 id="预防存储型XSS和反射型XSS攻击："><a href="#预防存储型XSS和反射型XSS攻击：" class="headerlink" title="预防存储型XSS和反射型XSS攻击："></a>预防存储型XSS和反射型XSS攻击：</h6><ul><li>纯前端渲染（这样就不会拼接html返回了）</li><li>同上面常用的防范手段一样的转义html</li></ul><h6 id="x3D-x3D-预防DOM型XSS攻击-x3D-x3D"><a href="#x3D-x3D-预防DOM型XSS攻击-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;预防DOM型XSS攻击&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>预防DOM型XSS攻击</strong>&#x3D;&#x3D;</h6><p>DOM型XSS攻击实际上是JavaScript代码本身不够严谨，</p><ul><li><code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。（尽量避免这种直接插入式的写法）</li><li>Vue的 <code>v-html</code>也容易导致xss攻击（原理也是innerHTML），与此同时，<code>v-html</code>也会替换掉标签内部子元素，所以 <code>v-html</code>尽量别用</li><li>减少<code>eval()</code>的使用</li></ul><h4 id="CSP内容安全策略"><a href="#CSP内容安全策略" class="headerlink" title="CSP内容安全策略"></a>CSP内容安全策略</h4><h6 id="CSP是什么"><a href="#CSP是什么" class="headerlink" title="CSP是什么"></a>CSP是什么</h6><p>内容安全策略 (<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSP">CSP</a>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting">XSS (en-US)</a>) 和数据注入攻击等。</p><p>CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是<strong>由浏览器自己实现</strong>的。我们可以通过这种方式来尽量减少 XSS 攻击。</p><h6 id="使用（开启-CSP）"><a href="#使用（开启-CSP）" class="headerlink" title="使用（开启 CSP）"></a>使用（开启 CSP）</h6><ol><li>设置 HTTP Header 中的 <code>Content-Security-Policy</code>（有时你会看到一些关于<code>X-Content-Security-Policy</code>头部的提法, 那是旧版本，你无须再如此指定它）</li></ol><p><a href="https://content-security-policy.com/">Content-Security-Policy的更多属性设置</a></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//policy参数是一个包含了各种描述你的CSP策略指令的字符串。</span>Content<span class="token operator">-</span>Security<span class="token operator">-</span>Policy<span class="token punctuation">:</span> policy<span class="token comment" spellcheck="true">//只允许加载本站资源</span>Content<span class="token operator">-</span>Security<span class="token operator">-</span>Policy<span class="token punctuation">:</span> <span class="token keyword">default</span><span class="token operator">-</span>src <span class="token string">'self'</span><span class="token comment" spellcheck="true">//允许内容来自信任的域名及其子域名 (域名不必须与CSP设置所在的域名相同)</span>Content<span class="token operator">-</span>Security<span class="token operator">-</span>Policy<span class="token punctuation">:</span> <span class="token keyword">default</span><span class="token operator">-</span>src <span class="token string">'self'</span> <span class="token operator">*</span><span class="token punctuation">.</span>trusted<span class="token punctuation">.</span>com<span class="token comment" spellcheck="true">//允许任何来源的框架</span>Content<span class="token operator">-</span>Security<span class="token operator">-</span>Policy<span class="token punctuation">:</span> children<span class="token operator">-</span>src <span class="token string">'none'</span><span class="token comment" spellcheck="true">//只允许加载https协议的图片</span>Content<span class="token operator">-</span>Security<span class="token operator">-</span>Policy<span class="token punctuation">:</span> img<span class="token operator">-</span>src https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">*</span><span class="token comment" spellcheck="true">//脚本：只信任当前域名</span><span class="token comment" spellcheck="true">//&lt;object>标签：不信任任何URL，即不加载任何资源</span><span class="token comment" spellcheck="true">//样式表：只信任cdn.example.org和third-party.org 空格的意思是这里要打一个空格但是我的屏幕显示不出来</span><span class="token comment" spellcheck="true">//框架（frame）：必须使用HTTPS协议加载</span><span class="token comment" spellcheck="true">//其他资源：没有限制</span>Content<span class="token operator">-</span>Security<span class="token operator">-</span>Policy<span class="token punctuation">:</span> script<span class="token operator">-</span>src <span class="token string">'self'</span><span class="token punctuation">;</span> object<span class="token operator">-</span>src <span class="token string">'none'</span><span class="token punctuation">;</span> style<span class="token operator">-</span>src cdn<span class="token punctuation">.</span>example<span class="token punctuation">.</span>org空格third<span class="token operator">-</span>party<span class="token punctuation">.</span>org<span class="token punctuation">;</span> child<span class="token operator">-</span>src https<span class="token punctuation">:</span></code></pre><p>每个限制选项可以设置以下几种值，这些值就构成了白名单。</p><blockquote><ul><li>主机名：<code>example.org</code>，<code>https://example.com:443</code></li><li>路径名：<code>example.org/resources/js/</code></li><li>通配符：<code>*.example.org</code>，<code>*://*.example.com:*</code>（表示任意协议、任意子域名、任意端口）</li><li>协议名：<code>https:</code>、<code>data:</code></li><li>关键字<code>&#39;self&#39;</code>：当前域名，需要加引号</li><li>关键字<code>&#39;none&#39;</code>：禁止加载任何外部资源，需要加引号</li></ul></blockquote><p><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">更多可以收看阮一峰老师的教程</a></p><ol start="2"><li>在HTML的，放到<code>head</code>区域设置 <code>meta</code> 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ol><h2 id="2-防止SQL注入（SQL-Injection）"><a href="#2-防止SQL注入（SQL-Injection）" class="headerlink" title="2.防止SQL注入（SQL Injection）"></a>2.防止SQL注入（SQL Injection）</h2><h4 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h4><p>没有过滤敏感字符，绑定变量，导致攻击者可以通过sql灵活多变的语法，构造精心巧妙的语句，不择手段，达成目的，或者通过<a href="http://www.2cto.com/os/">系统</a>报错，返回对自己有用的信息。</p><p>eg：<code>select * from users where username=&#39;&#39; or 1=1</code></p><h4 id="防止SQL注入，总的来说有以下几点："><a href="#防止SQL注入，总的来说有以下几点：" class="headerlink" title="防止SQL注入，总的来说有以下几点："></a>防止SQL注入，总的来说有以下几点：</h4><ol><li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。</li><li>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</li><li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>继续校验输入数据中是否包含SQL语句的保留字，如：WHERE，EXEC，DROP等。</li><li>预编译，在SQL映射文件中尽量使用#指示符标识参数位置，避免使用$。</li><li>确认每种数据的类型，比如是数字，数据库则必须使用int类型来存储</li><li>规定数据长度，能在一定程度上防止sql注入</li><li>严格限制数据库权限，能最大程度减少sql注入的危害</li><li>避免直接响应一些sql异常信息，sql发生异常后，自定义异常进行响应</li><li>过滤参数中含有的一些数据库关键词</li></ol><h2 id="3-CSRF"><a href="#3-CSRF" class="headerlink" title="3.CSRF"></a>3.CSRF</h2><h4 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h4><p>CSRF（Cross-Site Request Forgery）是一种跨站请求伪造，也被称为one-click-attack或者session riding，通常缩写为CSRF或XSRF，是一种挟持用户在当前已登录的Web应用程序上执行非本意的操作的攻击方式，跟XSS相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。</p><p>简单地说，CSRF就是利用用户的登录态发起恶意请求。</p><p><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">下面的图源自这个大佬</a></p><p><img src="https://taylor12138.gitee.io/2021/03/15/an-quan-wen-ti-hui-zong/csrf.jpg" alt="https://taylor12138.gitee.io/2021/03/15/an-quan-wen-ti-hui-zong/csrf.jpg"></p><h4 id="触发条件："><a href="#触发条件：" class="headerlink" title="触发条件："></a>触发条件：</h4><ul><li>用户登录并且信任网站A，并产生cookie</li><li>未登出A的情况下，访问网站B（此网站虽然是攻击网站，但是它可能是一个存在其他漏洞的可信任的经常被人访问的网站）</li></ul><p>（感觉通俗来讲就是，你在存放重要信息的网站A登录后，没有关闭且 &#x3D;&#x3D;<strong>本地的cookie没有过期</strong>&#x3D;&#x3D;，登陆了另外一个（攻击）网站，&#x3D;&#x3D;<strong>它就会偷你的cookie，冒充你来操作你网站A的账号</strong>&#x3D;&#x3D;）</p><h4 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h4><ul><li><p>Get类型的CSRF</p><p>假设网站有一个通过Get请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p><pre class=" language-html"><code class="language-html">&lt;img src = "http://www.domain.com/xxx?comment='attack'"></code></pre></li><li><p>POST类型的CSRF</p><pre class=" language-html"><code class="language-html">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.domain.com/xxx<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CSRF<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>comment<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>attack<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre></li><li><p>链接类型的CSRF，上面两种打开网页就中招，这种要点击的，比较low</p></li></ul><p>再来一个生动的例子认识CSRF：</p><p>用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。</p><p>攻击者就可以在网页放一个表单，该表单提交src为<code>http://www.bank.com/api/transfer</code>，body为<code>count=1000&amp;to=Tom</code>。</p><p>倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了（此时cookie会根据path和domain发现当前访问域名和银行相同，则&#x3D;&#x3D;<strong>携带cookie信息</strong>&#x3D;&#x3D;），由此形成CSRF攻击。</p><h4 id="防御CSRF"><a href="#防御CSRF" class="headerlink" title="防御CSRF"></a>防御CSRF</h4><p>防御CSRF攻击可以遵循以下几种规则：</p><ol><li>Get请求不对数据进行修改</li><li>不让第三方网站访问到Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，例如验证码或者token</li></ol><p>防御措施：</p><ul><li><p>SameSite：可以对Cookie设置SameSite属性，该属性设置Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前不是所有浏览器都兼容。</p><p>它可以设置三个值。</p><ul><li><p>Strict：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</span>Set<span class="token operator">-</span>Cookie<span class="token punctuation">:</span> CookieName<span class="token operator">=</span>CookieValue<span class="token punctuation">;</span> SameSite<span class="token operator">=</span>Strict<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</span></code></pre></li><li><p>Lax</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//Lax 规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</span>Set<span class="token operator">-</span>Cookie<span class="token punctuation">:</span> CookieName<span class="token operator">=</span>CookieValue<span class="token punctuation">;</span> SameSite<span class="token operator">=</span>Lax<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Chrome 计划将 Lax 变为默认设置。这时，网站可以选择显式关闭 SameSite 属性，将其设为 None 。不过，前提是必须同时设置 Secure 属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</span></code></pre></li><li><p>None</p></li></ul><p>下面的设置无效：</p><pre class=" language-javascript"><code class="language-javascript">Set<span class="token operator">-</span>Cookie<span class="token punctuation">:</span> widget_session<span class="token operator">=</span>abc123<span class="token punctuation">;</span> SameSite<span class="token operator">=</span>None</code></pre><p>下面的设置有效：</p><pre class=" language-javascript"><code class="language-javascript">Set<span class="token operator">-</span>Cookie<span class="token punctuation">:</span> widget_session<span class="token operator">=</span>abc123<span class="token punctuation">;</span> SameSite<span class="token operator">=</span>None<span class="token punctuation">;</span> Secure</code></pre><p>要使用 SameSite 属性，前提是用户浏览器支持 SameSite 属性，可以使用 <a href="https://link.segmentfault.com/?enc=12HbbkbA+HIQqE8POCpZZQ==.hB92U4yPxcxn7qN8uDbBQT4O87EmdWUK1FwBOcoHivi3+v2jKX7QSpn48ZAy9iij">caniuse</a> 查看浏览器对于 SameSite 属性的支持。</p></li><li><p>验证码：CSRF 攻击往往是在用户不知情的情况下成功伪造请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求，而且因为 CSRF 攻击无法获取到验证码，因此通常情况下，验证码能够很好地遏制 CSRF 攻击。</p><p>强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差。</p></li><li><p>同源检测</p><p>在 HTTP 协议中，每一个异步请求都会携带两个 Header ，用于标记来源域名：</p><ul><li>Origin Header</li><li>Referer Header</li></ul><p><img src="https://segmentfault.com/img/remote/1460000021114681" alt="img"></p><p>这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。</p><p>通过校验请求的该字段，我们能知道请求是否是从本站发出的。我们可以通过拒绝非本站发出的请求，来避免了 CSRF 攻击。</p><h4 id="验证-Origin"><a href="#验证-Origin" class="headerlink" title="验证 Origin"></a>验证 Origin</h4><p>如果 Origin 存在，那么直接使用 Origin 中的字段确认来源域名就可以。</p><p>但是 Origin 在以下两种情况下并不存在：</p><ul><li>1、 IE11同源策略： IE 11 不会在跨站 CORS 请求上添加 Origin 头，Referer 头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考 <a href="https://link.segmentfault.com/?enc=DysUUInE3g44UXx7CHx1xQ==.B+et3oSiznTg7fd4Jtr3A/og88lFSw3Myf5PC2ceU+TFjadpN5Z4NVptaTJfn0UKz1i2wouiXhwBmQk2IAEgFYfKQ6dXT/bIg2D1uy86d/A=">MDN Same-origin_policy#IE_Exceptions</a></li><li>2、 302重定向： 在302重定向之后 Origin 不包含在重定向的请求中，因为 Origin 可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的 URL ，因此浏览器不想将 Origin 泄漏到新的服务器上。</li></ul><h4 id="验证-Referer"><a href="#验证-Referer" class="headerlink" title="验证 Referer"></a>验证 Referer</h4><p>如果 Referer 存在，也可以用来确认 HTTP 请求的来源地址。</p><p>需要注意的是在以下情况下 Referer 没有或者不可信：</p><ul><li>1.IE6、7下使用<code>window.location.href=url</code>进行界面的跳转，会丢失 Referer。</li><li>2.IE6、7下使用<code>window.open</code>，也会缺失 Referer。</li><li>3.HTTPS 页面跳转到 HTTP 页面，所有浏览器 Referer 都丢失。</li><li>4.点击 Flash 上到达另外一个网站的时候，Referer 的情况就比较杂乱，不太可信。</li></ul><p>总的来说，同源检测是一个相对简单的防范方法，能够防范绝大多数的 CSRF 攻击，但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p></li><li><p>验证Http的Referer字段：请求来源限制，即同源检测，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。也就是通过判断该请求是否为第三方网站发起。</p></li><li><p>token：要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 Token，并在服务器端建立一个拦截器来验证这个 Token，如果请求中没有 Token 或者 Token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>token 验证的 CSRF 防御机制是公认最合适的方案。若网站同时存在 XSS 漏洞的时候，这个方法也是空谈，因为XSS攻击有可能泄露Token。</p><h5 id="添加-Token-验证的步骤："><a href="#添加-Token-验证的步骤：" class="headerlink" title="添加 Token 验证的步骤："></a>添加 Token 验证的步骤：</h5><p><strong>1、服务器将 Token 返回到前端</strong><br>用户打开页面时，前端发起请求，服务器会返回一个 Token，该 Token 通过加密算法对数据进行加密，一般 Token 都包括随机字符串和时间戳的组合，同时 Token 会存在服务器的 Session 中。之后页面加载完成时，使用 JS 遍历整个 DOM 树，在 DOM 中所有地址是本站的 <code>a</code> 和 <code>form</code> 标签中加入 Token，其他的请求就在编码时手动添加 Token 这个参数。</p><p><strong>2、前端发请求时携带这个 Token</strong><br>对于GET请求，Token 将附在请求地址之后，这样 URL 就变成 <code>http://url?token=tokenvalue</code>。 而对于 <code>form</code> 标签发起的 POST 请求来说，要在 <code>form</code> 的最后加上：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span>”hidden”</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span>”token”</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span>”tokenvalue”/</span><span class="token punctuation">></span></span></code></pre><p>总之，就是前端发请求时把 Token 以参数的形式加入请求中。</p><p><strong>3、服务器验证 Token 是否正确</strong><br>当前端得到了 Token ，再次提交给服务器的时候，服务器需要判断 Token 的有效性，验证过程是先解密 Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个 Token 就是有效的。</p><p>Token注意：</p><ol><li>Token 保存在 Session 中。假如 Token 保存在 Cookie 中，用户浏览器开了很多页面。在一些页面 Token 被使用消耗掉后新的Token 会被重新种入，但那些老的 Tab 页面对应的 HTML 里还是老 Token。这会让用户觉得为啥几分钟前打开的页面不能正常提交？</li><li>尽量少用 GET。假如攻击者在我们的网站上传了一张图片，用户在加载图片的时候实际上是向攻击者的服务器发送了请求，这个请求会带有referer表示当前图片所在的页面的 url。 而如果使用 GET 方式接口的话这个 URL 就形如： <a href="https://link.zhihu.com/?target=https://xxxx.com/gift?giftId=aabbcc&_csrf_token=xxxxx">https://xxxx.com/gift?giftId=aabbcc&_csrf_token&#x3D;xxxxx</a><br>，那相当于攻击者就获取了_csrf_token，短时间内可以使用这个 token 来操作其他 GET 接口。</li></ol></li></ul><p><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">结合代码讲解攻击与防御</a></p><p><a href="https://juejin.cn/post/6844903689702866952">防范措施讲得很好的</a></p><p><a href="https://juejin.cn/post/6844903689702866952">讲得还可以的博客</a></p><h2 id="4-劫持"><a href="#4-劫持" class="headerlink" title="4.劫持"></a>4.劫持</h2><h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><p>DNS ： 域名 -&gt; ip地址 ，进行域名解析的服务器</p><p>DNS劫持又称域名劫持，是指通过某些手段取得某域名的解析控制权，修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址。</p><p>DNS劫持其实并不是真的“黑掉”了对方的网站，而是冒名顶替、招摇撞骗罢了</p><p>案例</p><ul><li>在查找本机系统是否缓存ip地址时，可能碰到黑客设置绑定好的解析ip（host文件），使得我们到达了一个错误的ip地址（本地DNS劫持）;</li><li>亦或者是像《巴西银行钓鱼事件》，黑客利用D-Link路由器的漏洞，更改对应的DNS配置，重新定向到黑客自己搭建的恶意DNS服务器上（DNS解析路径劫持）</li></ul><p>（DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在<code>/etc/resolv.conf</code>文件。）</p><h4 id="防止DNS劫持"><a href="#防止DNS劫持" class="headerlink" title="防止DNS劫持"></a>防止DNS劫持</h4><p>网络层面：</p><ul><li>手动修改DNS</li><li>修改路由密码</li></ul><p>应用层面：</p><ul><li>安装杀毒软件，防御木马病毒和恶意软件；定期修改路由器管理账号密码和更新固件。</li><li>有点复杂，可以网上查询（泪。。）</li></ul><p><strong>HTTP劫持</strong></p><p>你DNS解析的域名的IP地址不变。在和网站交互过程中的劫持了你的请求。在网站发给你信息前就给你返回了请求。</p><p>HTTP劫持很好判断，当年正常访问一个无广告的页面时，页面上出现广告弹窗，八成就是运营商劫持了HTTP。</p><h2 id="5-序列化"><a href="#5-序列化" class="headerlink" title="5.序列化"></a>5.序列化</h2><h4 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h4><p>简单来说，序列化可以理解为就是将对象转化为字节流，字节流中包括这个对象的数据和信息，序列化和反序列化便于类的持久保存，并且很利于网络传输</p><p>而在反序列化处理中，如果攻击者通过构建恶意输入，使得反序列化产生非预期的类或者对象，这个类或者对象就有可能带来任意代码的执行</p><p>所以这个问题的根源在于，字节流进行还原时，即用到ObjectInputStream在反序列化时，没有对生成的对象的类型做限制</p><h2 id="6-DDos攻击"><a href="#6-DDos攻击" class="headerlink" title="6.DDos攻击"></a>6.DDos攻击</h2><p>DOS：Denial of Service，拒绝服务，通过占用网络资源让它应接不暇，从而拒绝正常业务流量的一种网络攻击方式</p><p>DDOS：Distributed denial of service，分布式拒绝服务，俗称群殴（单台设备攻击能力有限，但是成百上千设备同时攻击很猛）</p><p>发起攻击的网络（组成成百上千设备的攻击网络）称为僵尸网络</p><p>这个网络可以通过木马、蠕虫等感染大量设备从而获取僵尸网络（亦或者富人直接买就行了）</p><p>DDos攻击可以出现在网络的很多层：</p><ol><li>网络层：霸占服务器网络带宽资源，发送大量的IP协议数据包（比如ping工具，产生ICMP包），这种攻击方式也称为ICMP flood</li><li>除此之外还有 UDP flood<ul><li>多损的招数：</li><li>反射攻击：伪造自身ip地址为攻击目标的地址，然后向大量第三方机器发送请求，然后让第三方机器回复的响应大量涌入攻击目标ip</li><li>放大攻击：一次DNS查询，返回的数据往往大于请求数据，根据带宽放大因子，一般60B的请求数据可以获得3000B的返回数据，此时再结合反射攻击，让DNS返回的数据响应到攻击地址上，更加BT（maybe，50倍的攻击效果）</li></ul></li><li>TCP flood，因为有三次握手，所以无法伪装ip</li><li>RST洪水攻击，同样是利用TCP协议，一方可以发送RST数据强行切断连接，而不用四次挥手，此时我们让攻击设备不断尝试伪造各种ip地址，发送RST数据，进行盲打，此时有可能可以命中某位xx用户的连接</li></ol><h4 id="反击"><a href="#反击" class="headerlink" title="反击"></a>反击</h4><p>根治DDos攻击的方法：</p><ul><li>网络设备检测ip，过滤掉伪装的ip地址</li><li>根据路由转发逻辑，过滤伪装ip</li></ul><p>保守治疗：</p><ul><li>使用CDN节点</li><li>流量清洗设备（有点像保镖），先自己来应答，如果是正常的流量就放行</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络笔记</title>
      <link href="/2022/07/29/ji-suan-ji-wang-luo/"/>
      <url>/2022/07/29/ji-suan-ji-wang-luo/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常见状态码"><a href="#1-常见状态码" class="headerlink" title="1.常见状态码"></a>1.常见状态码</h2><ul><li>1xx: 接受，继续处理</li><li>200: 成功，并返回数据</li><li>201: 已创建</li><li>202: 已接受</li><li>203: 成为，但未授权</li><li>204: 成功，无内容</li><li>205: 成功，重置内容</li><li>206: 成功，部分内容</li><li>301: 永久移动，重定向</li><li>302: 临时移动，可使用原有URI</li><li>303: 明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。</li><li>304: 资源未修改，可使用缓存</li><li>305: 需代理访问</li><li>307: 会遵照浏览器标准，不会从post变为get。 </li><li>400: 请求语法错误</li><li>401: 要求身份认证</li><li>403: 拒绝请求</li><li>404: 资源不存在</li><li>410: </li><li>500: 服务器错误</li></ul><h2 id="2-get-x2F-post"><a href="#2-get-x2F-post" class="headerlink" title="2.get &#x2F; post"></a>2.get &#x2F; post</h2><ul><li>get: 缓存、请求长度受限、会被历史保存记录<ul><li>无副作用(不修改资源)，幂等(请求次数与资源无关)的场景</li></ul></li><li>post: 安全、大数据、更多编码类型</li></ul><p>两者详细对比如下图：</p><p><code>GET是进行明文传递，POST非明文请求数据放在请求体中</code></p><p><img src="/../img/168e9d9050b9d08a~tplv-t2oaga2asx-watermark.awebp.png"></p><h2 id="3-TCP是什么-x2F-TCP-的特性"><a href="#3-TCP是什么-x2F-TCP-的特性" class="headerlink" title="3.TCP是什么&#x2F;TCP 的特性"></a>3.TCP是什么&#x2F;TCP 的特性</h2><ul><li>TCP 提供一种<strong>面向连接的、可靠的</strong>字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于TCP</li><li>TCP 使用校验和，确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说TCP也不是 100%可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。</p><p>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种<code>双工服务</code>。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。</p><p>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h4 id="怎么让不可靠的-UDP可靠"><a href="#怎么让不可靠的-UDP可靠" class="headerlink" title="怎么让不可靠的 UDP可靠"></a><a href="https://www.infoq.cn/article/how-to-make-udp-reliable">怎么让不可靠的 UDP可靠</a></h4><h4 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h4><p>文章转自<a href="http://feinibuke.blog.51cto.com/1724260/340272">TCP和UDP区别</a></p><table><thead><tr><th align="left">-</th><th align="left">TCP</th><th align="left">UDP</th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">面向连接</td><td align="left">面向非连接</td></tr><tr><td align="left">传输可靠性</td><td align="left">可靠的</td><td align="left">不可靠的</td></tr><tr><td align="left">应用场合</td><td align="left">传输大量的数据</td><td align="left">少量数据</td></tr><tr><td align="left">速度</td><td align="left">慢</td><td align="left">快</td></tr></tbody></table><p>OSI 和 TCP&#x2F;IP 模型在传输层定义两种传输协议：TCP（或传输控制协议）和 UDP（或用户数据报协议）。</p><h6 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h6><p><strong><code>UDP</code> 与 <code>TCP</code> 的主要区别在于 <code>UDP</code> 不一定提供可靠的数据传输。</strong><br>事实上，该协议不能保证数据准确无误地到达目的地。UDP 在许多方面非常有效。当某个程序的目标是尽快地传输尽可能多的信息时（其中任意给定数据的重要性相对较低），可使用UDP。ICQ短消息使用UDP协议发送消息。</p><p>许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。</p><h6 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h6><p><code>TCP</code>的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。<code>TCP</code>在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。记住，较低的网络层会将每个数据包视为一个独立的单元，因此，数据包可以沿完全不同的路径发送，即使它们都是同一消息的组成部分。这种路由与网络层处理分段和重新组装数据包的方式非常相似，只是级别更高而已。</p><p>为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。</p><h6 id="TCP与UDP的选择"><a href="#TCP与UDP的选择" class="headerlink" title="TCP与UDP的选择"></a>TCP与UDP的选择</h6><p>如果比较<code>UDP</code>包和<code>TCP</code>包的结构，很明显<code>UDP</code>包不具备<code>TCP</code>包复杂的可靠性与控制机制。与TCP协议相同，UDP的源端口数和目的端口数也都支持一台主机上的多个应用。一个16位的UDP包包含了一个字节长的头部和数据的长度，校验码域使其可以进行整体校验。（许多应用只支持UDP，如：多媒体数据流，不产生任何额外的数据，即使知道有破坏的包也不进行重发。）</p><p>很明显，当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP是最好的选择。</p><p>在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP也是一个好的选择，如：DNS交换。把SNMP建立在UDP上的部分原因是设计者认为当发生网络阻塞时，UDP较低的开销使其有更好的机会去传送管理数据。TCP丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP可靠的点对点连接将会用于绝大多数的网络应用。</p><h6 id="TCP协议和UDP协议特性区别总结："><a href="#TCP协议和UDP协议特性区别总结：" class="headerlink" title="TCP协议和UDP协议特性区别总结："></a>TCP协议和UDP协议特性区别总结：</h6><ol><li>TCP协议在传送数据段的时候要给段标号；UDP协议不</li><li>TCP协议可靠；UDP协议不可靠</li><li>TCP协议是面向连接；UDP协议采用无连接</li><li>TCP协议负载较高，采用虚电路；UDP采用无连接</li><li>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</li><li>TCP协议采用窗口技术和流控制</li></ol><h2 id="3-TCP三次握手"><a href="#3-TCP三次握手" class="headerlink" title="3.TCP三次握手"></a>3.TCP三次握手</h2><p>所谓三次握手(Three-way Handshake)，是指&#x3D;&#x3D;建立一个 TCP 连接时，需要客户端和服务器总共发送3个包&#x3D;&#x3D;。</p><p>三次握手的目的是连接服务器指定端口，建立TCP连接，并&#x3D;&#x3D;同步连接双方的序列号和确认号&#x3D;&#x3D;，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p><ul><li><p>第一次握手(SYN&#x3D;1, seq&#x3D;x):</p><p>客户端发送一个 TCP 的 SYN 标志位置1的包，&#x3D;&#x3D;<strong>指明客户端打算连接的服务器的端口</strong>&#x3D;&#x3D;，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态，等待确认。</p></li><li><p>第二次握手(SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y, ACKnum&#x3D;x+1):</p><p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</p></li><li><p>第三次握手(ACK&#x3D;1，ACKnum&#x3D;y+1)</p><p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p><p>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</p><p><img src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-made-three-way-handshake.png"></p></li></ul><p>为何需要三次握手而不能两次：**<code>为了防止已失效的连接请求报文段突然又传送到了服务端，而产生错误</code>**</p><h2 id="4-TCP四次挥手"><a href="#4-TCP四次挥手" class="headerlink" title="4. TCP四次挥手"></a>4. TCP四次挥手</h2><p>&#x3D;&#x3D;TCP 的连接的拆除需要发送四个包&#x3D;&#x3D;，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p><ul><li><p>第一次挥手(FIN&#x3D;1，seq&#x3D;x)</p><p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</p></li><li><p>第二次挥手(ACK&#x3D;1，ACKnum&#x3D;x+1)</p><p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p></li><li><p>第三次挥手(FIN&#x3D;1，seq&#x3D;y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</p></li><li><p>第四次挥手(ACK&#x3D;1，ACKnum&#x3D;y+1)</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p><p><img src="https://raw.githubusercontent.com/HIT-Alibaba/interview/master/img/tcp-connection-closed-four-way-handshake.png"></p></li></ul><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">讲得很好的握手挥手</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516">深入TCP</a></p><h2 id="5-TCP-拥塞控制"><a href="#5-TCP-拥塞控制" class="headerlink" title="5.TCP 拥塞控制"></a>5.TCP 拥塞控制</h2><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复。</p><h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。（&#x3D;&#x3D;<strong>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小</strong>&#x3D;&#x3D;）</p><p>慢开始算法步骤具体如下</p><ol><li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li><li>每过一个 RTT 就将窗口大小乘二</li><li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li></ol><h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。（&#x3D;&#x3D;<strong>拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长</strong>&#x3D;&#x3D;）</p><p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 1 MSS</li><li>启动拥塞避免算法</li></ul><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。（&#x3D;&#x3D;<strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期</strong>&#x3D;&#x3D;）具体算法分为两种：</p><p><strong>TCP Taho 实现如下</strong></p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 1 MSS</li><li>重新开始慢开始算法</li></ul><p><strong>TCP Reno 实现如下</strong></p><ul><li>拥塞窗口减半</li><li>将阈值设为当前拥塞窗口</li><li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li><li>使用拥塞避免算法</li></ul><h4 id="TCP-New-Ren-改进后的快恢复"><a href="#TCP-New-Ren-改进后的快恢复" class="headerlink" title="TCP New Ren 改进后的快恢复"></a>TCP New Ren 改进后的快恢复</h4><p><strong>TCP New Reno</strong> 算法改进了之前 <strong>TCP Reno</strong> 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p><p>在 <strong>TCP New Reno</strong> 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p><p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p><p><a href="https://taylor12138.gitee.io/2021/03/15/chao-wen-ben-chuan-shu-xie-yi/">超详细的Http</a></p><h2 id="6-HTTP"><a href="#6-HTTP" class="headerlink" title="6.HTTP"></a>6.HTTP</h2><h4 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h4><ol><li>HTTP（HyperText Transfer Protocol 超文本传输协议）是WEB的应用层协议，它是Web的核心；HTTP有两部分实现，一个客户端程序一个服务器程序；HTTP定义了客户和服务器进行报文交换的方法； </li><li>HTTP使用<strong>TCP</strong>作为它的传输层协议；HTTP客户<strong>首先发起一个与服务器的TCP连接</strong>，需要注意的是，服务器根据请求作出响应，但是不存储任何关于该客户的状态信息；也正因为这样，HTTP被称为<strong>无状态协议</strong>。同时，Web使用了客户端-服务器的应用体系结构；其中web服务器总是开着的</li></ol><h5 id="持续连接和非持续连接"><a href="#持续连接和非持续连接" class="headerlink" title="持续连接和非持续连接"></a>持续连接和非持续连接</h5><p> HTTP既可使用持续连接也可以使用非持续连接。尽管&#x3D;&#x3D;<strong>HTTP在默认情况下使用持续连接</strong>&#x3D;&#x3D;     </p><ul><li><p>采用非持续连接的HTTP</p><ol><li><p>使用非持续连接时，每个TCP连接在服务器发送一个对象后就会关闭，也就是每个TCP只传送一个请求报文和响应报文；</p></li><li><p>建立一个TCP连接需要三次握手，步骤如下：</p><ol><li>第一次握手：建立连接时，客户端发送&#x3D;&#x3D;syn包&#x3D;&#x3D;（seq&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 </li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;j+1），同时自己发送一个ACK包（seq&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1)（<strong>通常会结合一个HTTP报文一起发送</strong>），发送完毕后，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><p>因此客户端请求一个对象所需的时间为 2个RTT的时间（三次握手的前两次占一个RTT，发送报文到服务器并且接收完服务器发送回来的资源占一个RTT）</p></li></ol></li><li><p>采用持续连接的HTTP</p><p>从上面可以看出：</p><ol><li>非持续连接必须为每个请求新建一个TCP连接，而每个TCP连接将占用系统资源，包括缓冲区和变量等，这样服务器的负担就很重了。</li><li>一个对象将通过两个RTT的时延才能交付。</li></ol><p>如果使用持续连接，那么服务器在发送响应报文后将保持该TCP打开，后续客户端可以使用该连接来向服务器发出请求。不但一个完整的页面可以通过同一个连接传送，同一台服务器上的多个页面也可以通过同一个连接发送。这就&#x3D;&#x3D;提高了效率&#x3D;&#x3D;；</p></li></ul><p><strong>一般来说，如果一条持续连接在一定的时间间隔后没被使用的话，就会被关闭。HTTP默认使用的是带流水线的持续连接。</strong></p><h5 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h5><h6 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h6><p>  <img src="/../img/1609158520658.png" alt="1609158520658"></p><p>   一个请求报文具有至少一行的内容。请求报文的第一行称为<strong>请求行</strong>，其后继的各行被称为<strong>首部行</strong>。</p><ol><li><p>请求行包含三个内容：</p><ul><li>方法字段（GET、POST、PUT、DELETE、HEAD等）</li><li>URL字段（可以传递请求对象的标志）</li><li>HTTP版本</li></ul></li><li><p>首部行包含：</p><ul><li>是否在发送完响应报文后关闭TCP连接的Connection</li><li>请求的主机地址（该头部信息被Web高速缓存所要求）</li><li>浏览器版本</li><li>可接受的语言等头部信息</li></ul></li><li><p>首部行之后有一个空行，之后便是请求的<strong>实体体</strong>（entity body）。</p><p>该实体体可以在POST方法里传递Form表单内容或者传递其它一些二进制流数据等。值得注意的是，表单也不一定必须使用POST方法。如果使用get,实体体为空，会显示在url中。</p></li><li><p>Head类似于get方法，将会用一个http报文进行响应，但是不返回请求对象，经常用作调试跟踪。</p></li><li><p>put方法允许用户上传对象到指定的Web服务器上指定的路径。</p></li><li><p>Delete方法允许用户或应用程序删除Web服务器上的对象。</p></li></ol><h6 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h6><p><img src="/../img/1609159256967.png" alt="1609159256967"></p><p> 响应报文总体上也分三个部分</p><ol><li><strong>状态行</strong>，包含HTTP版本、状态码以及状态信息（对状态码进行描述）等内容； </li><li><strong>首部行</strong>，包含发送日期、服务器类型、上一次修改请求资源的时间、内容的类型等内容</li><li><strong>实体体</strong>，实体体包含客户端所请求的对象本身。</li></ol><p>常见状态码</p><ul><li>200：请求成功 <ul><li>处理方式：获得响应的内容，进行处理</li></ul></li><li>301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源 <ul><li>处理方式：重定向到分配的URL</li></ul></li><li>400：非法请求 <ul><li>处理方式：丢弃</li></ul></li><li>404：没有找到所请求的资源或对象<ul><li>处理方式：丢弃</li></ul></li><li>505：服务器不支持请求报文使用的http版本</li></ul><h5 id="http协议的特点"><a href="#http协议的特点" class="headerlink" title="http协议的特点"></a>http协议的特点</h5><ul><li>永远都是客户端发起请求，服务器回送响应</li><li>http协议是无状态的，但是在实际工作中，一些万维网网站希望能识别用户（给用户推销产品）&#x3D;&gt;诞生了cookie小饼干，cookie是存储在用户主机的文本文件，记录一段时间内某用户的访问记录（不太敏感的数据）</li><li>http采用TCP作为运输层协议，但是http协议本身是无连接的 （交换http报文之前不需要建立连接）</li><li>http连接方式：持久连接（非流水线式（有点像停等协议）、流水线式（有点像GBN或SR协议，即后退N帧协议和选择重传协议））、非持久连接（每次传输都要三次握手）</li></ul><h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">HTTP请求方法</a></h4><h2 id="7-HTTP-1-0、HTTP-1-1、SDPY、HTTP2-0、HTTPS区别"><a href="#7-HTTP-1-0、HTTP-1-1、SDPY、HTTP2-0、HTTPS区别" class="headerlink" title="7.HTTP 1.0、HTTP 1.1、SDPY、HTTP2.0、HTTPS区别"></a>7.HTTP 1.0、HTTP 1.1、SDPY、HTTP2.0、HTTPS区别</h2><h3 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h3><ol><li><strong>缓存处理</strong>，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong>，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>错误通知的管理</strong>，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>Host头处理</strong>，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li><li><strong>长连接</strong>，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 HTTP1.1流水线（Pipelining）其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，<strong>客户端还是要按照发送请求的顺序来接收响应！</strong> 因此存在线头阻塞。</li></ol><h3 id="SPDY和HTTP1-x的区别"><a href="#SPDY和HTTP1-x的区别" class="headerlink" title="SPDY和HTTP1.x的区别"></a>SPDY和HTTP1.x的区别</h3><p>2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p><ol><li><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking（ 队首阻塞 Head-of-line blocking ）的问题，降低了延迟同时提高了带宽的利用率。</li><li><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</li><li><strong>header压缩。</strong>前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</li><li><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。（SPDY规定通信中需要使用SSL）</li><li><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：</li></ol><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribjhshzcKo97UNNVIFgpOYZic95drsxo5TaiadPSSmcYhOI7GYAO99W6Sw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p><h3 id="SPDY和HTTP2-0的区别"><a href="#SPDY和HTTP2-0的区别" class="headerlink" title="SPDY和HTTP2.0的区别"></a>SPDY和HTTP2.0的区别</h3><p>HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：</p><p>HTTP2.0和SPDY的区别：</p><ol><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 <strong>HPACK</strong>，而非 SPDY 采用的 <strong>DEFLATE</strong></li></ol><h3 id="HTTP2-0和HTTP1-x的区别"><a href="#HTTP2-0和HTTP1-x的区别" class="headerlink" title="HTTP2.0和HTTP1.x的区别"></a>HTTP2.0和HTTP1.x的区别</h3><ul><li><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 HTTP2.0中，有两个⾮常重要的概念，分别是帧（frame）和流（stream）。 帧代表着最⼩的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复⽤，就是在一个TCP连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免HTTP旧版本中的队头阻塞问题，极⼤的提⾼传输性能。&#x3D;&#x3D;<strong>（使用二进制传输，减少服务端压力，连接吞吐量更大，改善TCP拥塞状况，同时慢启动时间减少）</strong>&#x3D;&#x3D;</li><li><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。不存在HTTP1.1的线头阻塞&#x3D;&#x3D;<strong>（多路复用允许同时通过单一的HTTP&#x2F;2连接发起多重的请求&#x2F;响应消息）</strong>&#x3D;&#x3D;</li><li><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。&#x3D;&#x3D;<strong>（最小数据量化）</strong>&#x3D;&#x3D;</li><li><strong>服务端推送</strong>（server push），同SPDY一样，HTTP2.0也具有server push功能。</li></ul><blockquote><p>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</p></blockquote><ul><li><p>HTTP&#x2F;1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</p></li><li><p>HTTP&#x2F;1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</p></li><li><p>HTTP&#x2F;2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；<br>具体如图：</p></li></ul><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQriba5ygCTOOjIQH4wvoJS2iaFBseyEAUfvpJQThHmTjuGuaSspUo8xppiaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h3 id="HTTPS与HTTP的区别"><a href="#HTTPS与HTTP的区别" class="headerlink" title="HTTPS与HTTP的区别"></a>HTTPS与HTTP的区别</h3><ul><li><p>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。</p></li><li><p>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL&#x2F;TLS之上，SSL&#x2F;TLS运行在TCP之上，所有传输的内容都经过加密的。</p></li><li><p>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p></li><li><p>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribXL5PwzkqQdmyY9egu2hpzzMCgz2F5HhhkdSNc5eYJ9UGMDBGjeCGiag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p></li></ul><h3 id="HTTPS-握手"><a href="#HTTPS-握手" class="headerlink" title="HTTPS 握手"></a>HTTPS 握手</h3><p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。</p><h2 id="8-TLS"><a href="#8-TLS" class="headerlink" title="8.TLS"></a>8.TLS</h2><p>TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。</p><p>在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p><p><strong>对称加密</strong>：</p><p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p><p><strong>非对称加密</strong>：</p><p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p><strong>TLS 握手过程如下图：</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/12/1635260126b3a10c~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ol><li>客户端发送一个随机值，需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li></ol><p>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</p><p>PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。</p><h2 id="9-中间人攻击"><a href="#9-中间人攻击" class="headerlink" title="9.中间人攻击"></a>9.中间人攻击</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过一个私密的连接与对⽅直接对话，但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p><h4 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h4><ol><li>首先中间人（攻击者）需要有一套自己的数字证书</li><li>当客户端第一次发送信息给服务器时，中间人<strong>获取到第一个随机数</strong>，并将信息原样转发给服务器</li><li>服务器接收到客户端信息，将公钥发送给客户端，中间人截取请求，<strong>获取第二个随机数</strong>，并<strong>将服务器的公钥替换成自己的公钥</strong>并发送给客户端</li><li>客户端接收到<strong>中间人的公钥</strong>，用公钥加密<strong>第三个随机数和hash值</strong>并发送给服务器，中间人再次截取请求，用自己的私钥解密，<strong>获取第三个随机数，此时中间人得知秘钥</strong>，同时要根据自己与服务器的通信信息生成假的hash值替换掉客户端发送的hash值，再将这些信息用服务器的公钥加密，发送给服务器</li><li>服务器用自己的私钥解密请求，校验hash值并根据三个随机数生成秘钥，加密三次握手的hash值并发送给客户端，中间人截取请求，用已成功 “ 窃取 ”的秘钥进行解密，将hash值替换成假的hash值并重新加密发送给客户端</li><li>客户端接收到请求，用三个随机数生成的秘钥进行解密，校验无误，开始用秘钥同服务器进行对称加密的通信，这时，<strong>客户端，中间人，服务器都持有同一个秘钥，因此中间人可以对客户端和服务器的加密信息进行对称解密</strong></li></ol><h4 id="如何防范中间人攻击？"><a href="#如何防范中间人攻击？" class="headerlink" title="如何防范中间人攻击？"></a>如何防范中间人攻击？</h4><ol><li>在上述中间人攻击中，中间人之所以可以进行攻击主要是自己替换了服务器的公钥，所以防范中间人攻击需要引入CA数字证书</li><li>CA是数字证书认证机构，而数字证书就是申请人将一些必要信息（包括公钥、姓名、电子邮件、有效期）等提供给 CA，而CA用自己的私钥对申请人所提供信息计算散列值进行加密，形成数字签名，附在数字证书并颁发给申请人，这样申请人发送公钥的时候也会提供对应的数字证书，便于接收人（客户端）验证公钥是发送方（服务器）而不是中间人的。</li><li>CA机构也有层级关系，如A机构颁发数字证书，B机构保证A机构合法性，C机构保证B机构的合法性，直到根CA保证。所以如果这个保证链中一个机构自己偷偷非法颁发数字证书或根CA的私钥泄露，那么数字证书提供的安全性也就不存在了。</li></ol><h2 id="10-DNS解析"><a href="#10-DNS解析" class="headerlink" title="10.DNS解析"></a>10.DNS解析</h2><p>DNS的作用就是通过域名查找到具体的IP</p><h4 id="输入www-google-com-DNS解析流程："><a href="#输入www-google-com-DNS解析流程：" class="headerlink" title="输入www.google.com DNS解析流程："></a>输入<a href="http://www.google.com/">www.google.com</a> DNS解析流程：</h4><ol><li>在本地缓存中查询（一般来说，因为hosts优先级较高，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。）</li><li>没有的话会去系统配置的DNS服务器查询</li><li>没有的话会去DNS根服务器查询，这一步查询会找出负责com这个一级域名的服务器</li><li>然后去该服务器查询google这个二级域名</li><li>接下来三级域名的查询是可以配置的，可以给www这个域名配置一个IP，然后还可以给别的三级域名配置一个IP</li></ol><p>以上便是DNS的迭代查询，还有一种是递归查询，区别就是前者由客户端去做请求，后者是由系统配置的DNS服务器做请求，得到结果后将数据返回给客户端。</p><p>DNS是基于UDP做的查询</p><h4 id="DNS的优化与应用"><a href="#DNS的优化与应用" class="headerlink" title="DNS的优化与应用"></a>DNS的优化与应用</h4><blockquote><ol><li>DNS缓存 <code>DNS存在着多级缓存</code>，从离浏览器的距离排序的话，有以下几种: <code>浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</code>。</li><li>DNS负载均衡<code>(DNS重定向) DNS负载均衡技术</code>的实现原理是在DNS服务器中为同一个主机名配置多个IP地址，在应答DNS查询时， DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问 引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。</li></ol><ul><li>大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟 用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</li></ul><ol start="3"><li>dns-prefetch <code>DNS Prefetch 是一种 DNS 预解析技术</code>。当你浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，这样在你单击当前网页中的连接时就无需进行DNS的解析，减少用户等待时间，提高用户体验。</li></ol></blockquote><h2 id="11-在浏览器中输入www-google-com-会发生什么"><a href="#11-在浏览器中输入www-google-com-会发生什么" class="headerlink" title="11.在浏览器中输入www.google.com 会发生什么"></a>11.在浏览器中输入<a href="http://www.google.com/">www.google.com</a> 会发生什么</h2><p><a href="https://www.h5w3.com/20238.html">讲得很详细的博客</a></p><ol><li><p><strong>URL解析</strong>：首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p></li><li><p><strong>缓存判断</strong>：</p><ol><li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li><li>操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，那就去操作系统中找。</li><li>路由缓存：路由器也有 DNS 缓存。</li></ol><p>如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p></li><li><p><strong>DNS查询</strong>：见10</p></li><li><p><strong>获取MAC地址</strong>：当浏览器得到IP地址后，数据传输还需要知道目的主机MAC地址，因为应用层下发数据给传输层，TCP协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的IP地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的MAC地址，本机的MAC地址作为源MAC地址，目的MAC地址需要分情况处理。通过将IP地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用APR协议获取到目的主机的MAC地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过ARP协议来获取网关的MAC地址，此时目的主机的MAC地址应该为网关的地址。</p></li><li><p><strong>TCP三次握手</strong>：见3， TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个SYN连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p></li><li><p><strong>HTTP请求</strong>：浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面，注意如果是HTTPS协议的话，还有一个TLS四次握手</p></li><li><p><strong>返回数据</strong>：当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p></li><li><p><strong>页面渲染：</strong></p><p><a href="https://juejin.cn/post/6844903476506394638#heading-6">浏览器渲染的博客，此处不深入</a></p><blockquote><p>URL请求的数据类型，有时候是下载类型，有时候是HTML页面，那么浏览器怎么区分呢？</p><p>​通过 Content-Type 字段。Content-Type是HTTP头部中的重要字段，它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。比如Content-Type的值是application&#x2F;octet-stream，通常情况下，浏览器会按照下载类型来处理该请求，该请求被提交给浏览器的下载管理器，同时该URL请求的导航流程就此结束；如果Content-Type字段的值是text&#x2F;html，这就是告诉浏览器，服务器返回的数据是HTML格式，浏览器会继续导航流程，接下来渲染进程登场了。</p></blockquote><ol><li>浏览器首先会根据 html 文件构建 DOM 树。</li><li>计算DOM树上的CSS属性，根据解析到的 CSS 文件构建 CSSOM 树<ol><li>如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，前者会并行进行下载并执行JS，后者会先下载文件，如果都没有，就会阻塞渲染流程直到JS执行完毕，这里使用HTTP2.0协议的话会极大多图的下载速度。</li></ol></li><li>当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</li></ol></li><li><p><strong>TCP四次挥手：</strong>最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p></li></ol><h2 id="12-session、cookie、localStorage、sessionStorage的区别"><a href="#12-session、cookie、localStorage、sessionStorage的区别" class="headerlink" title="12.session、cookie、localStorage、sessionStorage的区别"></a>12.session、cookie、localStorage、sessionStorage的区别</h2><p><a href="https://www.cnblogs.com/jing-tian/p/10991431.html">这篇讲得超级好球你了看一看吧</a></p><h4 id="一、Cookie、session和localStorage的区别"><a href="#一、Cookie、session和localStorage的区别" class="headerlink" title="一、Cookie、session和localStorage的区别"></a><strong>一、Cookie、session和localStorage的区别</strong></h4><ul><li>cookie的内容主要包括：名字、值、过期时间、路径和域。路径与域一起构成cookie的作用范围。若不设置时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失。这种生命期为浏览器会话期的cookie被称为会话cookie。 </li><li>会话cookie一般不存储在硬盘而是保存在内存里，当然这个行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再打开浏览器这些cookie仍然有效直到超过设定的过期时间。对于保存在内存里的cookie，不同的浏览器有不同的处理方式session机制。 </li><li>当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。</li></ul><h4 id="二、cookie和session的区别"><a href="#二、cookie和session的区别" class="headerlink" title="二、cookie和session的区别"></a><strong>二、cookie和session的区别</strong></h4><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上</li><li>cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑<em>到安全应当使用session</em></li><li>session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie </li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie </li><li>建议将登录信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中 </li><li>session保存在服务器，客户端不知道其中的信心；cookie保存在客户端，服务器能够知道其中的信息 </li><li>session中保存的是对象，cookie中保存的是字符串 </li><li>session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到，而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的。 </li><li>cookie：是服务端向客户端写入的小的片段信息。cookie信息保存在服务器缓存区，不会在客户端显现。当你第一次登陆一个网站，服务器向你的机器写得片段信息。你可以在Internet选项中找到存放cookie的文件夹。如果不删除，cookie就一直在这个文件夹中。 </li><li>session需要借助cookie才能正常工作。如果客户端完全禁止cookie，session将失效。 但是如果服务器端启用了url编码，也就是用 URLEncoder.encode()把所有的url编码了，则会在url后面出现如下类似的东西 index.jsp:jsessionid&#x3D;fdsaffjdlks;jaf;lkdjsf 服务器通过这个进行session的判断。</li><li>Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等,而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。</li></ol><h4 id="三、web-Storage和Cookie的区别"><a href="#三、web-Storage和Cookie的区别" class="headerlink" title="三、web Storage和Cookie的区别"></a><strong>三、web Storage和Cookie的区别</strong></h4><p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用。<br>除此之外，web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。<br>但是cookie也是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生<br>sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的</p><ol><li>Web Storage带来的好处：<br>减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递 </li><li>快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示 </li><li>临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便</li></ol><h4 id="四、浏览器本地存储与服务器端存储的区别"><a href="#四、浏览器本地存储与服务器端存储的区别" class="headerlink" title="四、浏览器本地存储与服务器端存储的区别"></a><strong>四、浏览器本地存储与服务器端存储的区别</strong></h4><p>其实数据既可以在浏览器本地存储，也可以在服务器端存储。</p><p>浏览器可以保存一些数据，需要的时候直接从本地存取，sessionStorage、localStorage和cookie都是由浏览器存储在本地的数据 服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。<br>服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端<br>服务器端也可以保存用户的临时会话数据，服务器端的session机制，如jsp的session对象，数据保存在服务器上，实际上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象，会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期</p><p>服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分别保存在用户各自的浏览器中，浏览器端一般只用来存储小数据，而非服务可以存储大数据或小数据服务器存储数据安全一些，浏览器只适合存储一般数据</p><h4 id="五、sessionStorage、localStorage和cookie的区别"><a href="#五、sessionStorage、localStorage和cookie的区别" class="headerlink" title="五、sessionStorage、localStorage和cookie的区别"></a><strong>五、sessionStorage、localStorage和cookie的区别</strong></h4><p>共同点：都是保存在浏览器端、且同源的<br>区别：<br>1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下<br>2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大<br>3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭<br>4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的<br>5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者<br>6、web Storage的api接口使用更方便</p><h4 id="六、sessionStorage与页面js数据对象的区别"><a href="#六、sessionStorage与页面js数据对象的区别" class="headerlink" title="六、sessionStorage与页面js数据对象的区别"></a><strong>六、sessionStorage与页面js数据对象的区别</strong></h4><ul><li>页面中一般的js对象的生存期仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了</li><li>而sessionStorage只要同源的同窗口中，刷新页面或进入同源的不同页面，数据始终存在，也就是说只要浏览器不关闭，数据仍然存在</li></ul><h3 id="13-说一下HTTP-3-0"><a href="#13-说一下HTTP-3-0" class="headerlink" title="13.说一下HTTP 3.0"></a>13.说一下HTTP 3.0</h3><p>HTTP&#x2F;3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-9b0f553d-3c6e-43a3-8185-8565f9fa1fb4.webp" alt="image"></p><ol><li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li><li>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</li><li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li><li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。</li></ol><h2 id="20-RestFul与RPC区别-RestFul-优点"><a href="#20-RestFul与RPC区别-RestFul-优点" class="headerlink" title="20.RestFul与RPC区别 RestFul 优点"></a>20.RestFul与RPC区别 RestFul 优点</h2><p><a href="https://zhuanlan.zhihu.com/p/34440779">直接看博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>html知识点</title>
      <link href="/2022/07/29/html-mian-shi-ti/"/>
      <url>/2022/07/29/html-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h3><p>src和href都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p><ul><li><strong>src：</strong>表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，&#x3D;&#x3D;<strong>会暂停其他资源的下载和处理</strong>&#x3D;&#x3D;，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li><li><strong>href：</strong>表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它指向的⽂件时，就&#x3D;&#x3D;<strong>会并⾏下载资源</strong>&#x3D;&#x3D;，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li></ul><h3 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2. 对HTML语义化的理解"></a>2. 对HTML语义化的理解</h3><p><strong>语义化是指</strong>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。</p><p>语义化的优点如下：</p><ul><li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li><li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li></ul><p> 常见的语义化标签：</p><pre><code>&lt;header&gt;&lt;/header&gt;  头部&lt;nav&gt;&lt;/nav&gt;  导航栏&lt;section&gt;&lt;/section&gt;  区块（有语义化的div）&lt;main&gt;&lt;/main&gt;  主要区域&lt;article&gt;&lt;/article&gt;  主要内容&lt;aside&gt;&lt;/aside&gt;  侧边栏&lt;footer&gt;&lt;/footer&gt;  底部</code></pre><h3 id="4-script标签中defer和async的区别"><a href="#4-script标签中defer和async的区别" class="headerlink" title="4. script标签中defer和async的区别"></a>4. script标签中defer和async的区别</h3><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p><p>下图可以直观的看出三者之间的区别:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png" alt="image.png"></p><p>其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p><p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p><ul><li><strong>执行顺序：</strong>多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li><li><strong>脚本是否并行执行：</strong>async属性，表示<strong>后续文档的加载和执行与js脚本的加载和执行是并行进行的</strong>，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li></ul><h3 id="5-常⽤的meta标签有哪些"><a href="#5-常⽤的meta标签有哪些" class="headerlink" title="5. 常⽤的meta标签有哪些"></a>5. 常⽤的meta标签有哪些</h3><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p><p>常用的meta标签：</p><p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p><pre><code>&lt;meta charset=&quot;UTF-8&quot; &gt;</code></pre><p>（2） <code>keywords</code>，页面关键词：</p><pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;关键词&quot; /&gt;</code></pre><p>（3）<code>description</code>，页面描述：</p><pre><code>&lt;meta name=&quot;description&quot; content=&quot;页面描述内容&quot; /&gt;</code></pre><p>（4）<code>refresh</code>，页面重定向和刷新：</p><pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=&quot; /&gt;</code></pre><p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</code></pre><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>width viewport</code> ：宽度(数值&#x2F;device-width)</li><li><code>height viewport</code> ：高度(数值&#x2F;device-height)</li><li><code>initial-scale</code> ：初始缩放比例</li><li><code>maximum-scale</code> ：最大缩放比例</li><li><code>minimum-scale</code> ：最小缩放比例</li><li><code>user-scalable</code> ：是否允许用户缩放(yes&#x2F;no）</li></ul><p>（6）搜索引擎索引方式：</p><pre><code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot; /&gt;</code></pre><p>其中，<code>content</code> 参数有以下几种：</p><ul><li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li><li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li><li><code>index</code>：文件将被检索；</li><li><code>follow</code>：页面上的链接可以被查询；</li><li><code>noindex</code>：文件将不被检索；</li><li><code>nofollow</code>：页面上的链接不可以被查询。</li></ul><h3 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h3><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul><li>header：定义文档的页眉（头部）；</li><li>nav：定义导航链接的部分；</li><li>footer：定义文档或节的页脚（底部）；</li><li>article：定义文章内容；</li><li>section：定义文档中的节（section、区段）；</li><li>aside：定义其所处内容之外的内容（侧边）；</li></ul><h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><p>（1） audio：音频</p><pre><code>&lt;audio src=&#39;&#39; controls autoplay loop=&#39;true&#39;&gt;&lt;/audio&gt;</code></pre><p>属性：</p><ul><li>controls 控制面板</li><li>autoplay 自动播放</li><li>loop&#x3D;‘true’ 循环播放</li></ul><p>（2）video视频</p><pre><code>&lt;video src=&#39;&#39; poster=&#39;imgs/aa.jpg&#39; controls&gt;&lt;/video&gt;</code></pre><p>属性：</p><ul><li>poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。</li><li>controls 控制面板</li><li>width</li><li>height</li></ul><p>（3）source标签</p><p>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p><pre><code>&lt;video&gt;    &lt;source src=&#39;aa.flv&#39; type=&#39;video/flv&#39;&gt;&lt;/source&gt;    &lt;source src=&#39;aa.mp4&#39; type=&#39;video/mp4&#39;&gt;&lt;/source&gt;&lt;/video&gt;</code></pre><h4 id="3-表单"><a href="#3-表单" class="headerlink" title="3. 表单"></a>3. 表单</h4><p><strong>表单类型：</strong></p><ul><li>email ：能够验证当前输入的邮箱地址是否合法</li><li>url ： 验证URL</li><li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li><li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li><li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li><li>color ： 提供了一个取色板</li><li>time ： 时分秒</li><li>data ： 日期选择年月日</li><li>datatime ： 时间和日期(目前只有Safari支持)</li><li>datatime-local ：日期时间控件</li><li>week ：周控件</li><li>month：月控件</li></ul><p><strong>表单属性：</strong></p><ul><li><p>placeholder ：提示信息</p></li><li><p>autofocus ：自动获取焦点</p></li><li><p>autocomplete&#x3D;“on” 或者 autocomplete&#x3D;“off” 使用这个属性需要有两个前提：</p></li><li><ul><li>表单必须提交过</li><li>必须有name属性。</li></ul></li><li><p>required：要求输入框不能为空，必须有值才能够提交。</p></li><li><p>pattern&#x3D;” “ 里面写入想要的正则模式，例如手机号patte&#x3D;”^(+86)?\d{10}$”</p></li><li><p>multiple：可以选择多个文件或者多个邮箱</p></li><li><p>form&#x3D;” form表单的ID”</p></li></ul><p><strong>表单事件：</strong></p><ul><li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li><li>oninvalid 当验证不通过时触发此事件。</li></ul><h4 id="4-进度条、度量器"><a href="#4-进度条、度量器" class="headerlink" title="4. 进度条、度量器"></a>4. 进度条、度量器</h4><ul><li><p>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</p></li><li><p>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）</p></li><li><ul><li>high&#x2F;low：规定被视作高&#x2F;低的范围</li><li>max&#x2F;min：规定最大&#x2F;小值</li><li>value：规定当前度量值</li></ul></li></ul><p>设置规则：min &lt; low &lt; high &lt; max</p><h4 id="5-DOM查询操作"><a href="#5-DOM查询操作" class="headerlink" title="5.DOM查询操作"></a>5.DOM查询操作</h4><ul><li>document.querySelector()</li><li>document.querySelectorAll()</li></ul><p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p><h4 id="6-Web存储"><a href="#6-Web存储" class="headerlink" title="6. Web存储"></a>6. Web存储</h4><p>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage - 没有时间限制的数据存储</li><li>sessionStorage - 针对一个 session 的数据存储</li></ul><h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><ul><li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li></ul><pre><code>&lt;img draggable=&quot;true&quot; /&gt;</code></pre><ul><li>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li></ul><pre><code>&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt;</code></pre><ul><li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li><li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</li></ul><p><strong>总结：</strong></p><p>（1）新增语义化标签：nav、header、footer、aside、section、article</p><p>（2）音频、视频标签：audio、video</p><p>（3）数据存储：localStorage、sessionStorage</p><p>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</p><p>（5）input标签新增属性：placeholder、autocomplete、autofocus、required</p><p>（6）history API：go、forward、back、pushstate</p><p><strong>移除的元素有：</strong></p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><h3 id="7-img的srcset属性的作⽤？"><a href="#7-img的srcset属性的作⽤？" class="headerlink" title="7. img的srcset属性的作⽤？"></a>7. img的srcset属性的作⽤？</h3><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p><pre><code>&lt;img src=&quot;image-128.png&quot; srcset=&quot;image-256.png 2x&quot; /&gt;</code></pre><p>使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。</p><p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：</p><pre><code>&lt;img src=&quot;image-128.png&quot;     srcset=&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;     sizes=&quot;(max-width: 360px) 340px, 128px&quot; /&gt;</code></pre><p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p><p>sizes语法如下：</p><pre><code>sizes=&quot;[media query] [length], [media query] [length] ... &quot;</code></pre><p>sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</p><h3 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><ul><li>行内元素有：<code>a b span img input select strong</code>；</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li></ul><p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p><ul><li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li><li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li></ul><h3 id="9-说一下-web-worker"><a href="#9-说一下-web-worker" class="headerlink" title="9. 说一下 web worker"></a>9. 说一下 web worker</h3><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 </p><p>如何创建 web worker： </p><ol><li>检测浏览器对于 web worker 的支持性 </li><li>创建 web worker 文件（js，回传函数等） </li><li>创建 web worker 对象</li></ol><h3 id="10-HTML5的离线储存怎么使用，它的工作原理是什么"><a href="#10-HTML5的离线储存怎么使用，它的工作原理是什么" class="headerlink" title="10. HTML5的离线储存怎么使用，它的工作原理是什么"></a>10. HTML5的离线储存怎么使用，它的工作原理是什么</h3><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p><p><strong>原理：</strong>HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p><p><strong>使用方法：</strong></p><p>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p><pre><code>&lt;html lang=&quot;en&quot; manifest=&quot;index.manifest&quot;&gt;</code></pre><p>（2）在 <code>index.manifest</code> 文件中编写需要离线存储的资源：</p><pre><code>#v0.11CACHE:js/app.jscss/style.cssNETWORK:resourse/logo.pngFALLBACK:offline.html</code></pre><ul><li><strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li><li><strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li><li><strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li></ul><p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p><p><strong>如何更新缓存：</strong></p><p> （1）更新 manifest 文件</p><p> （2）通过 javascript 操作</p><p> （3）清除浏览器缓存</p><p><strong>注意事项：</strong></p><p> （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p><p> （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p><p> （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p><p> （4）FALLBACK 中的资源必须和 manifest 文件同源。</p><p> （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p><p> （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p><p> （7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p><h3 id="11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？"><a href="#11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？" class="headerlink" title="11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？"></a>11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h3><ul><li><strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li><li><strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li></ul><h3 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h3><ul><li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li><strong>i内容展示为斜体，em表示强调的文本</strong></li></ul><h3 id="13-iframe-有那些优点和缺点？"><a href="#13-iframe-有那些优点和缺点？" class="headerlink" title="13. iframe 有那些优点和缺点？"></a>13. <strong>iframe 有那些优点和缺点？</strong></h3><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p><p><strong>优点：</strong></p><ul><li>用来加载速度较慢的内容（如广告）</li><li>可以使脚本可以并行下载</li><li>可以实现跨子域通信</li></ul><p><strong>缺点：</strong></p><ul><li>iframe 会阻塞主页面的 onload 事件</li><li>无法被一些搜索引擎所识别</li><li>会产生很多页面，不容易管理</li></ul><h3 id="14-label-的作用是什么？如何使用？"><a href="#14-label-的作用是什么？如何使用？" class="headerlink" title="14. label 的作用是什么？如何使用？"></a>14. label 的作用是什么？如何使用？</h3><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p><ul><li>使用方法1：</li></ul><pre><code>&lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;</code></pre><ul><li>使用方法2：</li></ul><pre><code>&lt;label&gt;Date:&lt;input type=&quot;text&quot;/&gt;&lt;/label&gt;</code></pre><h3 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h3><p><strong>（1）SVG：</strong></p><p>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p>其特点如下：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><p><strong>（2）Canvas：</strong></p><p>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p><p>其特点如下：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p><h3 id="19-渐进增强和优雅降级之间的区别"><a href="#19-渐进增强和优雅降级之间的区别" class="headerlink" title="19. 渐进增强和优雅降级之间的区别"></a>19. 渐进增强和优雅降级之间的区别</h3><p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。</p><p><strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p><p><strong>两者区别：</strong></p><ul><li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li><li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li></ul><h3 id="20-说一下-HTML5-drag-API"><a href="#20-说一下-HTML5-drag-API" class="headerlink" title="20. 说一下 HTML5 drag API"></a>20. 说一下 HTML5 drag API</h3><ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 </li><li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 </li><li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。 </li><li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 </li><li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 </li><li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 </li><li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li></ul><h3 id="documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？"><a href="#documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？" class="headerlink" title="documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？"></a>documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？</h3><p>MDN中对<code>documentFragment</code>的解释：</p><blockquote><p>DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</p></blockquote><p>当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将DocumentFragment（包括了其所有的子孙节点）插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，只会触发一次回流，这样就大大提高了页面的性能。</p><p>同时 DocumentFragment 也会被用来实现 WebComponent（原生组件）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS应用题</title>
      <link href="/2022/07/29/css-zhi-shi-dian/"/>
      <url>/2022/07/29/css-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h3 id="元素宽度不确定，实现固定宽高比"><a href="#元素宽度不确定，实现固定宽高比" class="headerlink" title="元素宽度不确定，实现固定宽高比"></a>元素宽度不确定，实现固定宽高比</h3><p>&#x3D;&#x3D;使用子元素的内边距撑开元素，这是因为子元素的内边距设置为百分比时是以父元素的宽度为基准的&#x3D;&#x3D;。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>padding<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token number">.</span>container&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>        <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span>container <span class="token number">.</span>padding&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">0</span>px<span class="token punctuation">;</span>        <span class="token property">padding-top</span><span class="token punctuation">:</span> <span class="token number">56.25%</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span>container <span class="token number">.</span>content&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p>优点：容易理解</p><p>缺点：增加了一个div节点用于撑开父元素（不利于后期维护），且需要再嵌套一层绝对定位元素用于处理容器内的内容。</p><p>使用伪元素margin-top&#x2F;margin-bottom撑开父元素</p><p>用CSS变量实现</p><pre class=" language-css"><code class="language-css">&lt;div class=<span class="token string">"container"</span>>    &lt;div class=<span class="token string">"content"</span>>&lt;/div>&lt;/div>&lt;style>    <span class="token number">.</span>container&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">--ratio</span><span class="token punctuation">:</span> <span class="token number">9</span> / <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token property">--widthSize</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token function">var</span><span class="token punctuation">(</span>--widthSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token function">var</span><span class="token punctuation">(</span>--widthSize<span class="token punctuation">)</span> * <span class="token function">var</span><span class="token punctuation">(</span>--ratio<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&lt;/style></code></pre><p>优点：无需使用子元素，利于维护</p><p>用CSS新属性aspect-ratio</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token number">.</span>container&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>        <span class="token property">aspect-ratio</span><span class="token punctuation">:</span> <span class="token number">16</span> / <span class="token number">9</span><span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/*这里不同于使用CSS变量实现，如果不加上该属性，那么当子元素超出时，容器高度将被撑开*/</span>        <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>     &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p>优点：容易理解，代码量少</p><p>缺点：由于是新属性，兼容性还有待提高</p><h3 id="消除浮动"><a href="#消除浮动" class="headerlink" title="消除浮动"></a>消除浮动</h3><p>不清除浮动会发生高度塌陷：浮动元素父元素高度自适应（父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷），所以清除浮动是为了不让父元素发生高度塌陷。</p><ul><li><p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式：</p><pre class=" language-css"><code class="language-css">&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">overflow</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p>给浮动元素父级设置高度（这个很好理解，清除浮动本质是为了让父元素有高度）</p></li><li><p>父级同时浮动（需要给父级同级元素添加浮动）</p></li><li><p>父级设置成inline-block，其margin: 0 auto居中方式失效</p></li><li><p>设置父级的overflow属性不为 visible 的其他值（scroll、hidden、auto）</p></li><li><p>万能清除法 after伪类 清浮动（现在主流方法，推荐使用） </p><pre class=" language-css"><code class="language-css"><span class="token number">.</span><span class="token property">float_div</span><span class="token punctuation">:</span><span class="token punctuation">:</span>after&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"."</span><span class="token punctuation">;</span>  <span class="token property">clear</span><span class="token punctuation">:</span>both<span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">overflow</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>  <span class="token property">visibility</span><span class="token punctuation">:</span>hidden<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li></ul><p>从上面我们可以看出，除了使用到<code>clear:both</code>的方法都与BFC容器有很大的关系，也就是说，本质上我们是父元素成为一个BFC从而清除浮动的。</p><h3 id="CSS文本溢出省略号？"><a href="#CSS文本溢出省略号？" class="headerlink" title="CSS文本溢出省略号？"></a>CSS文本溢出省略号？</h3><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/*单行溢出*/</span>div&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 强制文本不换行 */</span>    <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 隐藏溢出内容 */</span>    <span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 对溢出的文本用 ellipsis 省略号代替。 */</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*多行溢出*/</span>div&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span> -webkit-box<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 将对象作为弹性伸缩盒子模型显示 */</span>    <span class="token property">-webkit-box-orient</span><span class="token punctuation">:</span> vertical <span class="token comment" spellcheck="true">/* 使文本垂直（纵向）排列每一行，也就是文字是从左到右，从上到下 */</span>    <span class="token comment" spellcheck="true">/* 限制文本的行数 or 列数，取决于-webkit-box-orient的属性值 */</span>    <span class="token property">-webkit-line-clamp</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>         <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 隐藏溢出内容 */</span>    <span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 对溢出的文本用 ellipsis 省略号代替。 */</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h3 id="写出三栏布局，左右固定宽度，中间自适应"><a href="#写出三栏布局，左右固定宽度，中间自适应" class="headerlink" title="写出三栏布局，左右固定宽度，中间自适应"></a>写出三栏布局，左右固定宽度，中间自适应</h3><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>实现原理：<code>left</code>和<code>right</code>由于声明了<code>float</code>属性，因此都变成了BFC，而<code>center</code>由于声明了<code>overflow: hidden</code>，因此也为BFC；众所周知，BFC相互之间是独立、隔离的，因此实现了三栏布局。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layout float<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token number">.</span>layout<span class="token number">.</span>float <span class="token number">.</span>left &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>float <span class="token number">.</span>right &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">float</span><span class="token punctuation">:</span> right<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>float <span class="token number">.</span>center &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>            <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left-right-center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span></code></pre><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><p>实现原理：通过定位实现了<code>left、right、center</code>三个元素在空间上的分隔，而这三个元素由于设置了<code>position:absolute</code>，因此都为BFC容器，实现了其内容的隔离。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token number">.</span>left-center-right > div &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span>left &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>        <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span>right &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>        <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span>center &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>        <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>        <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left-center-right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>绝对定位---center部分<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span></code></pre><h4 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layout flex<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token number">.</span>layout<span class="token number">.</span>flex &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">margin-top</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>flex <span class="token number">.</span>left-center-right &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>flex <span class="token number">.</span>left &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>flex <span class="token number">.</span>right &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>flex <span class="token number">.</span>center &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left-center-right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>flex布局---center部分<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span></code></pre><h4 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layout grid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token number">.</span>layout<span class="token number">.</span>grid <span class="token number">.</span>left-center-right &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>            <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token number">300</span>px auto <span class="token number">300</span>px<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>grid <span class="token number">.</span>left &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>grid <span class="token number">.</span>right &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>grid <span class="token number">.</span>center &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left-center-right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Grid布局---center部分<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span></code></pre><h4 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h4><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>layout table<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token number">.</span>layout<span class="token number">.</span>table <span class="token number">.</span>left-center-right &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>table <span class="token number">.</span>left &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>table <span class="token number">.</span>right &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>layout<span class="token number">.</span>table <span class="token number">.</span>center &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> gold<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>article</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left-center-right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>表格布局---center部分<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>article</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span></code></pre><h4 id="5种方案的优缺点"><a href="#5种方案的优缺点" class="headerlink" title="5种方案的优缺点"></a>5种方案的优缺点</h4><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>浮动</td><td>兼容性好</td><td>清除浮动（脱离文档流，会带来很多问题）</td></tr><tr><td>绝对定位</td><td>快捷</td><td>脱离文档流</td></tr><tr><td>Flexbox</td><td>最全面，移动端很普及</td><td>兼容性</td></tr><tr><td>表格布局</td><td>兼容性好</td><td>单元格高度随着调整</td></tr><tr><td>Grid</td><td>替代栅格系统</td><td>兼容性</td></tr></tbody></table><h4 id="假如高度未知，哪个方案失效"><a href="#假如高度未知，哪个方案失效" class="headerlink" title="假如高度未知，哪个方案失效"></a>假如高度未知，哪个方案失效</h4><ul><li>浮动、绝对定位、Grid均会失效</li><li>flex、表格布局可以</li></ul><h3 id="如何实现一个元素水平垂直居中？"><a href="#如何实现一个元素水平垂直居中？" class="headerlink" title="如何实现一个元素水平垂直居中？"></a>如何实现一个元素水平垂直居中？</h3><ul><li>方法1 已知元素宽高：父元素相对定位，子元素绝对定位。设置子元素<code>left</code> <code>top</code> <code>right</code> <code>bottom</code>都为<code>0</code>, 外边距设置为<code>auto</code>;</li></ul><pre class=" language-css"><code class="language-css"><span class="token number">.</span>parent &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span>  <span class="token number">300</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token number">.</span>child &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">bottom</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><ul><li>方法2 已知元素宽高：父元素相对定位，子元素绝对定位。设置子元素<code>left</code> <code>top</code> 都为<code>50%</code>, <code>margin-left``margin-top</code>外边距设置为<strong>负的宽高的一半</strong>;</li></ul><pre class=" language-css"><code class="language-css"><span class="token number">.</span>child &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">margin-top</span><span class="token punctuation">:</span> -<span class="token number">50</span>px<span class="token punctuation">;</span>  <span class="token property">margin-left</span><span class="token punctuation">:</span> -<span class="token number">50</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><ul><li>方法3 未知元素宽高：父元素相对定位，子元素绝对定位。设置子元素的<code>left</code> <code>right</code> 都为<code>50%</code>，通过css平移属性向左和向上平移平移自身宽高的一半<code>transform: translate(-50%, -50%);</code></li></ul><pre class=" language-css"><code class="language-css"><span class="token number">.</span>child &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>  <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>  <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-<span class="token number">50%</span>, -<span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><ul><li>方法4 通过弹性盒属性设置在主轴和侧轴上居中对齐</li></ul><pre class=" language-css"><code class="language-css"><span class="token number">.</span>parent &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><ul><li>方法5 兼容IE8可以使用table相关属性</li></ul><pre class=" language-css"><code class="language-css"><span class="token number">.</span>parent &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> table<span class="token punctuation">;</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">300</span>px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid <span class="token hexcode">#ccc</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token number">.</span>parent <span class="token number">.</span>child &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> table-cell<span class="token punctuation">;</span>  <span class="token property">vertical-align</span><span class="token punctuation">:</span> middle<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token number">.</span>parent <span class="token number">.</span>child span &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* span会水平垂直巨中 */</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><ul><li>方法6 通过最新的网格布局来实现</li></ul><pre class=" language-css"><code class="language-css"><span class="token number">.</span>parent &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>  <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>  <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><ul><li>方法7 单行文字，设置行高等于自身高度，文本设置居中</li></ul><pre class=" language-css"><code class="language-css"><span class="token number">.</span>parent &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">22</span>px<span class="token punctuation">;</span>  <span class="token property">line-height</span><span class="token punctuation">:</span> <span class="token number">22</span>px<span class="token punctuation">;</span>  <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h3 id="如何使用css实现等宽布局？"><a href="#如何使用css实现等宽布局？" class="headerlink" title="如何使用css实现等宽布局？"></a>如何使用css实现等宽布局？</h3><pre class=" language-css"><code class="language-css"><span class="token number">.</span>parent &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token number">.</span>child &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">flex</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h3 id="如何实现满屏品字布局？"><a href="#如何实现满屏品字布局？" class="headerlink" title="如何实现满屏品字布局？"></a>如何实现满屏品字布局？</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">    html,body&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>        <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span>main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span> auto<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">700</span>px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span>nav&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span>frist, <span class="token number">.</span>two&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">display</span><span class="token punctuation">:</span> inline-block<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span>two&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nav<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>frist<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>two<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p><img src="https://files.catbox.moe/dzv6c2.png"></p><h3 id="实现一个扇形"><a href="#实现一个扇形" class="headerlink" title="实现一个扇形"></a>实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p><pre><code>div&#123;    border: 100px solid transparent;    width: 0;    heigt: 0;    border-radius: 100px;    border-top-color: red;&#125;</code></pre><p><img src="https://files.catbox.moe/qikz0z.png"></p><h3 id="画一条0-5px的线"><a href="#画一条0-5px的线" class="headerlink" title="画一条0.5px的线"></a>画一条0.5px的线</h3><ul><li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li></ul><pre><code>transform: scale(0.5,0.5);</code></pre><ul><li><strong>采用meta viewport的方式</strong></li></ul><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;/&gt;</code></pre><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p><h3 id="怎么让-Chrome-支持小于-12px-的文字？"><a href="#怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="怎么让 Chrome 支持小于 12px 的文字？"></a>怎么让 Chrome 支持小于 12px 的文字？</h3><ul><li>使用Webkit的内核的私有CSS属性来解决<code>-webkit-text-size-adjust:none</code>，设置后字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。</li><li>css3 的 transform 属性，设置值为 scale(x, y) 定义 2D 缩放转换。</li></ul><h2 id="CSS冷门八股"><a href="#CSS冷门八股" class="headerlink" title="CSS冷门八股"></a>CSS冷门八股</h2><h3 id="解决-img-图片自带边距的问题"><a href="#解决-img-图片自带边距的问题" class="headerlink" title="解决 img 图片自带边距的问题"></a>解决 img 图片自带边距的问题</h3><p>（1）转化成（行级）块元素</p><pre class=" language-css"><code class="language-css"> <span class="token property">display</span> <span class="token punctuation">:</span> block<span class="token punctuation">;</span></code></pre><p>（2）浮动，浮动后的元素默认可以转化为块元素（可以随意设置宽高属性）</p><pre class=" language-css"><code class="language-css"><span class="token property">float</span> <span class="token punctuation">:</span> left<span class="token punctuation">;</span></code></pre><p>（3）给 img 定义 vertical-align（消除底部边距）</p><pre class=" language-css"><code class="language-css">img&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token property">vertical-align</span><span class="token punctuation">:</span> bottom<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>（4）将其父容器的font-size 设为 0；</p><p>（5）给父标签设置与图片相同的高度</p><h3 id="li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#li-与-li-之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p>浏览器的默认行为是把 inline 元素间的空白字符（空格换行 tab）渲染成一个空格，也就是<li>换行后会产生换行字符，而它会变成一个空格，当然空格就占用一个字符的宽度。</p><p>解决方案：</p><p>方法一：既然是因为 <code>&lt;li&gt;</code> 换行导致的，那就可以将 <code>&lt;li&gt;</code> 代码全部写在一排，如下</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>li标签空白测试<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>part1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>part2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>part3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>part4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>方法二：我们为了代码美观以及方便修改，很多时候我们不可能将 <code>&lt;li&gt;</code> 全部写在一排，那怎么办？既然是空格占一个字符的宽度，那我们索性就将 <code>&lt;ul&gt;</code> 内的字符尺寸直接设为 0，将下面样式放入样式表，问题解决。</p><pre class=" language-css"><code class="language-css"><span class="token number">.</span>wrap ul &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token number">0</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>但随着而来的就是 <code>&lt;ul&gt;</code> 中的其他文字就不见了，因为其尺寸被设为 0px 了，我们只好将他们重新设定字符尺寸。</p><h3 id="css-sprite（雪碧图）是什么-有什么优缺点？"><a href="#css-sprite（雪碧图）是什么-有什么优缺点？" class="headerlink" title="css sprite（雪碧图）是什么, 有什么优缺点？"></a>css sprite（雪碧图）是什么, 有什么优缺点？</h3><p>概念：将多个小图片拼接到一个图片中。通过 background-position 和元素尺寸调节需要显示的背景图案。</p><p>优点：</p><ul><li>减少 HTTP 请求数，极大地提高页面加载速度。</li><li>增加图片信息重复度，提高压缩比，减少图片大小。</li><li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现。</li></ul><p>缺点：</p><ul><li>图片合并麻烦。</li><li>维护麻烦，修改一个图片可能需要从新布局整个图片，样式。</li></ul><h3 id="css-sprite和-base64-如何选择？"><a href="#css-sprite和-base64-如何选择？" class="headerlink" title="css sprite和 base64 如何选择？"></a>css sprite和 base64 如何选择？</h3><p>base64 适用场景：<br>应用于小的图片几 k 的，太大的图片会转换后的大小太大，得不偿失。<br>用于一些 css sprites 不利处理的小图片，如一些可以通过 background-repeat 平铺来做成背景的图片</p><h3 id="如果设计中使用了非标准的字体，你该如何去实现？"><a href="#如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="如果设计中使用了非标准的字体，你该如何去实现？"></a>如果设计中使用了非标准的字体，你该如何去实现？</h3><p>使用 <code>@font-face</code> 并为不同的 <code>font-weight</code> 定义 <code>font-family</code> 。</p><h3 id="在网页中的应该使用奇数还是偶数的字体？为什么呢？"><a href="#在网页中的应该使用奇数还是偶数的字体？为什么呢？" class="headerlink" title="在网页中的应该使用奇数还是偶数的字体？为什么呢？"></a>在网页中的应该使用奇数还是偶数的字体？为什么呢？</h3><p>参考答案：应该使用偶数字体</p><p>1. 比例关系</p><p>相对来说偶数字号比较容易和页面中其他部分的字号构成一个比例关系。如我使用 14px 的字体作为正文字号，那么其他部分的字体（如标题）就可以使用 14×1. 5 &#x3D;21px 的字体，或者在一些地方使用到了 14×0. 5&#x3D;7px 的 padding 或者 margin，如果你是在用 sass 或者 less 编写 css，这时候用处就凸显出来了。</p><p>2. UI 设计师的缘故</p><p>大多数设计师用的软件如 ps 提供的字号是偶数，自然到了   前端那边也是用的是偶数。</p><p>3. 浏览器缘故</p><p>其一是低版本的浏览器 ie6 会把奇数字体强制转化为偶数，即 13px 渲染为 14px。</p><p>其二是为了平分字体。偶数宽的汉字，如 12px 的汉子，去掉 1 像素的字体间距，填充了的字体像素宽度其实就是 11px，这样的汉字中竖线左右是平分的，如“中”子，左右就是 5px 了。</p><p>4. 系统差别</p><p>Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p><p>而在 Linux 和其他手持设备上，奇数偶数的渲染效果其实相差不大。</p><h3 id="CSS中使用列布局是什么？"><a href="#CSS中使用列布局是什么？" class="headerlink" title="CSS中使用列布局是什么？"></a>CSS中使用列布局是什么？</h3><p>CSS列布局帮助你分割文本变为列，例如考虑下面的杂志新闻在一个大的文本中，但是我们需要在他们之间使用边界划分为3列，这里HTML5的列布局就有所帮助了</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/27/16a5d9ddd53f7691~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/27/16a5d9eadc51d9bd~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h3 id="如何修改-chrome-记住密码后自动填充表单的黄色背景？"><a href="#如何修改-chrome-记住密码后自动填充表单的黄色背景？" class="headerlink" title="如何修改 chrome 记住密码后自动填充表单的黄色背景？"></a>如何修改 chrome 记住密码后自动填充表单的黄色背景？</h3><pre class=" language-css"><code class="language-css"><span class="token property">input</span><span class="token punctuation">:</span>-webkit-autofill &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">-webkit-box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>px <span class="token number">1000</span>px 颜色 inset<span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid <span class="token hexcode">#CCC</span>!important<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h3 id="除了-screen，你还能说出一个-media-属性的例子吗？"><a href="#除了-screen，你还能说出一个-media-属性的例子吗？" class="headerlink" title="除了 screen，你还能说出一个 @media 属性的例子吗？"></a>除了 screen，你还能说出一个 @media 属性的例子吗？</h3><ul><li><p>all</p><p>适用于所有设备。</p></li><li><p>print</p><p>为了加载合适的文档到当前使用的可视窗口. 需要提前咨询 paged media（媒体屏幕尺寸）, 以满足个别设备网页尺寸不匹配等问题。</p></li><li><p>screen</p><p>主要适用于彩色的电脑屏幕</p></li><li><p>speech</p><p>speech 这个合成器. 注意: CSS2 已经有一个相似的媒体类型叫 aural</p></li></ul><h3 id="让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用 CSS 怎么做？"></a>让页面里的字体变清晰，变细用 CSS 怎么做？</h3><p><code>-webkit-font-smoothing: antialiased;</code> </p><h3 id="font-style-属性的值为-oblique-时是什么意思？"><a href="#font-style-属性的值为-oblique-时是什么意思？" class="headerlink" title="font-style 属性的值为 oblique 时是什么意思？"></a>font-style 属性的值为 oblique 时是什么意思？</h3><p>Oblique是让没有斜体属性的文字倾斜</p><h3 id="无依赖绝对定位是什么？"><a href="#无依赖绝对定位是什么？" class="headerlink" title="无依赖绝对定位是什么？"></a>无依赖绝对定位是什么？</h3><pre><code>没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。</code></pre><h3 id="隐藏元素的方法有哪些"><a href="#隐藏元素的方法有哪些" class="headerlink" title="隐藏元素的方法有哪些"></a>隐藏元素的方法有哪些</h3><ul><li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><strong>clip&#x2F;clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li>**transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h2 id="CSS高频八股"><a href="#CSS高频八股" class="headerlink" title="CSS高频八股"></a>CSS高频八股</h2><h3 id="讲讲BFC"><a href="#讲讲BFC" class="headerlink" title="讲讲BFC"></a>讲讲BFC</h3><p><strong>什么是BFC</strong></p><p>BFC（Block Formatting Context）格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。</p><p><strong>形成 BFC 的条件:</strong></p><ul><li>浮动元素，float 除 none 以外的值</li><li>定位元素，position（absolute，fixed）</li><li>display 为以下其中之一的值 inline-block，table-cell，table-caption</li><li>overflow 除了 visible 以外的值（hidden，auto，scroll）</li><li>HTML 就是一个 BFC</li></ul><p><strong>BFC 的特性：</strong></p><ul><li>内部的 Box 会在垂直方向上一个接一个的放置。</li><li>垂直方向上的距离由 margin 决定</li><li>bfc 的区域不会与 float 的元素区域重叠。</li><li>计算 bfc 的高度时，浮动元素也参与计算</li><li>bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。</li></ul><h3 id="CSS的属性值-auto"><a href="#CSS的属性值-auto" class="headerlink" title="CSS的属性值 auto?"></a>CSS的属性值 auto?</h3><h4 id="width"><a href="#width" class="headerlink" title="width"></a>width</h4><ul><li>对于width来说，当子元素设置为 <code>width: auto</code>时，子元素的 <code>margin-left + margin-right + border-left + border-right + padding-left + padding-right + content-width</code> 对等于父元素的<code>content-width</code></li><li>当子元素设置为 <code>width:100%</code>时，将根据子元素的盒模型来调整：<ul><li>子元素为<code>content-box</code>时，子元素的<code>content-width</code>等于父元素的<code>content-width</code></li><li>子元素为<code>border-box</code>时，子元素的<code>border-left + border-right + padding-left + padding-right + content-width</code>等于父元素的<code>content-width</code></li></ul></li></ul><h4 id="height"><a href="#height" class="headerlink" title="height"></a>height</h4><ul><li>对于height来说，当子元素设置为<code>height:auto</code>时，其高度由其内容撑开，与父元素无关。</li><li>当子元素设置为<code>height:100%</code>，其表现与设置为<code>width:100%</code>一致。</li></ul><h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><p>子元素为非绝对定位元素时：</p><ul><li>margin的auto值只对 <code>margin-left</code>和<code>margin-right</code>有效，对<code>margin-top</code>和<code>margin-bottom</code>无效，相当于没有设置。</li><li>当只设置 <code>margin-left: auto</code>时，子元素的右侧贴近父元素<code>content</code>的右侧</li><li>当只设置<code>margin-right: auto</code>时，子元素的左侧贴近父元素<code>content</code>的左侧</li><li>当同时设置<code>margin-left: auto</code>、<code>margin-right: auto</code>时，子元素相当于父元素的<code>content</code>居中</li></ul><p>子元素为绝对定位元素时（absolute、fixed）,为<code>absolute</code>时父元素指代最近的不为static的上级元素、为<code>fixed</code>时父元素指代body</p><ul><li><p>当设置 <code>margin-left:auto</code>时，只有同时设置<code>left: 0</code>时才能生效；<code>margin-right</code>、<code>margin-top</code>、<code>margin-bottom</code>也类似，因此进行如下设置时，子元素相对于父元素（padding + content的区域）水平垂直居中。</p><pre class=" language-css"><code class="language-css"><span class="token number">.</span>child&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">left</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">top</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">right</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li></ul><p><strong>注意：当子元素不是绝对定位时，margin: auto 相对于父元素 content进行定位，当子元素为绝对定位元素时，margin: auto 相对于父元素 padding + content 进行定位。</strong></p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p><code>flex:auto</code>等价于<code>flex: 1 1 auto</code>，也就是<code>flex-grow: 1; flex-shrink: 1; flex-basis: auto;</code></p><h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>当元素设置<code>overflow:auto</code>时，当元素内容超出元素的高度和宽度时会显示滚动条。</p><p><code>overflow:auto</code>与<code>overflow:scroll</code>的区别是：</p><ul><li><code>overflow:scroll</code>无论元素内容是否超出元素的高度和宽度时都会显示纵向滚动条和横向滚动条</li><li><code>overflow:auto</code>只在元素内容超出元素的高度时显示纵向滚动条，元素内容超出元素宽度时显示横向滚动条。</li></ul><h4 id="left、right、top、bottom"><a href="#left、right、top、bottom" class="headerlink" title="left、right、top、bottom"></a>left、right、top、bottom</h4><p>当元素为<strong>非绝对定位</strong>元素时 <code>left、right、top、bottom</code>这些定位的<code>auto</code>值都无效，但当元素为<strong>绝对定位</strong>（absolute、fixed）时，这些属性则有各种的表现形式：</p><ul><li><code>left:auto</code>：<code>left</code>属性的值相当于<strong>父元素</strong>的<code>padding-left</code>值，也就是元素的左侧会贴在父元素<code>content-box</code>的左侧</li><li><code>top:auto</code>：<code>top</code>属性的值相当于<strong>父元素</strong>的<code>padding-top</code>值，也就是元素的上侧会贴在父元素<code>content-box</code>的上侧</li><li><code>right:auto</code>：<code>right</code>属性的值为元素<code>padding-box</code>的右侧到父元素的<code>padding-box</code>下侧的距离</li><li><code>bottom:auto</code>：<code>bottom</code>属性的值为元素<code>padding-box</code>的下侧到父元素的<code>padding-box</code>下侧的距离</li></ul><p>left、right、top、bottom的优先级：</p><ul><li>当同时设置了<code>left</code>和<code>right</code>时，<code>left</code>优先设置，有一种情况例外：当<code>left:auto</code>且<code>right</code>属性为具体数值（如<code>right:10px</code>），以right为优先、同理，<code>top</code>和<code>bottom</code>也是一样。</li></ul><p><strong>注意：当父元素设置 <code>direction: rtl</code>时，上述的<code>left</code>和<code>right</code>的表现形式和优先级逆转。</strong></p><h3 id="重置CSS-和-标准化CSS-的区别是什么？你会选择哪种方式，为什么？"><a href="#重置CSS-和-标准化CSS-的区别是什么？你会选择哪种方式，为什么？" class="headerlink" title="重置CSS 和 标准化CSS 的区别是什么？你会选择哪种方式，为什么？"></a>重置CSS 和 标准化CSS 的区别是什么？你会选择哪种方式，为什么？</h3><p>参考答案：</p><ul><li><strong>重置（Resetting）</strong>： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像 <code>margin</code> 、 <code>padding</code> 、 <code>font-size</code> 这些样式全部置成一样。你将必须重新定义各种元素的样式。</li><li><strong>标准化（Normalizing）</strong>： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。</li></ul><p>当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。</p><h3 id="设置元素浮动后，该元素的-display-值是什么？"><a href="#设置元素浮动后，该元素的-display-值是什么？" class="headerlink" title="设置元素浮动后，该元素的 display 值是什么？"></a>设置元素浮动后，该元素的 display 值是什么？</h3><p>自动变成 <code>display:block</code></p><h3 id="使用-clear-属性清除浮动的原理？"><a href="#使用-clear-属性清除浮动的原理？" class="headerlink" title="使用 clear 属性清除浮动的原理？"></a>使用 clear 属性清除浮动的原理？</h3><p>使用clear属性清除浮动，其语法如下：</p><pre class=" language-css"><code class="language-css"><span class="token property">clear</span><span class="token punctuation">:</span> none|left|right|both</code></pre><p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p><p><img src="C:\Users\HZR\OneDrive\图片\1638669840611.png" alt="1638669840611"></p><h3 id="行内元素和块级元素的具体区别是什么"><a href="#行内元素和块级元素的具体区别是什么" class="headerlink" title="行内元素和块级元素的具体区别是什么?"></a>行内元素和块级元素的具体区别是什么?</h3><p><strong>块级元素( block )特性：</strong></p><p>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示（浮动元素除外）；</p><p>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制；</p><p><img src="https://iknow-pic.cdn.bcebos.com/6a600c338744ebf8a67ad383d4f9d72a6059a707?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg" alt="img"></p><p><strong>内联元素(inline)特性：</strong></p><p>和相邻的内联元素在同一行;</p><p>宽度(width)、高度(height)、内边距的top&#x2F;bottom(padding-top&#x2F;padding-bottom)和外边距的top&#x2F;bottom(margin-top&#x2F;margin-bottom)都不可改变（也就是padding和margin的left和right是可以设置的）。</p><p><img src="https://iknow-pic.cdn.bcebos.com/42a98226cffc1e17fb093a8d4790f603728de9dc?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg" alt="img"></p><p><strong>行内块元素（inline-block）（拥有内在尺寸，可设置高宽，但不会自动换行）</strong></p><p>如：img、input</p><h3 id="元素竖向的百分比设定是相对于容器的高度吗？"><a href="#元素竖向的百分比设定是相对于容器的高度吗？" class="headerlink" title="元素竖向的百分比设定是相对于容器的高度吗？"></a>元素竖向的百分比设定是相对于容器的高度吗？</h3><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p><h3 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba() 和 opacity 的透明效果有什么不同？"></a>rgba() 和 opacity 的透明效果有什么不同？</h3><p>rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）</p><h3 id="px、em、rem的区别及使用场景"><a href="#px、em、rem的区别及使用场景" class="headerlink" title="px、em、rem的区别及使用场景"></a>px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em的值相对于其父元素字体的大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素字体的大小。而rem是相对于根元素字体，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="position-的不同值分别是相对于什么定位的？"><a href="#position-的不同值分别是相对于什么定位的？" class="headerlink" title="position 的不同值分别是相对于什么定位的？"></a>position 的不同值分别是相对于什么定位的？</h3><ul><li>absolute : 生成绝对定位的元素， 相对于最近一级的定位不是 static 的父元素来进行定位。</li><li>fixed （老 IE 不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。</li><li>relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。</li><li>static 默认值。没有定位，元素出现在正常的流中</li><li>sticky 生成粘性定位的元素，元素始终被限制在最近块级父元素的区域中，当未超出父元素区域时，显示效果相当于fixed。</li></ul> <img src="https://z3.ax1x.com/2021/11/21/Ivi34J.gif" alt="Ivi34J.gif" style="zoom:50%;" /><h3 id="如何解决不同浏览器的样式兼容性问题？"><a href="#如何解决不同浏览器的样式兼容性问题？" class="headerlink" title="如何解决不同浏览器的样式兼容性问题？"></a>如何解决不同浏览器的样式兼容性问题？</h3><ul><li>在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。</li><li>使用已经处理好此类问题的库，比如 Bootstrap。</li><li>使用 <code>autoprefixer</code> 自动生成 CSS 属性前缀。</li><li>使用 Reset CSS 或 Normalize. css。</li></ul><h3 id="什么情况下，用-translate-而不用绝对定位？什么时候下相反？"><a href="#什么情况下，用-translate-而不用绝对定位？什么时候下相反？" class="headerlink" title="什么情况下，用 translate() 而不用绝对定位？什么时候下相反？"></a>什么情况下，用 translate() 而不用绝对定位？什么时候下相反？</h3><p><code>translate()</code> 是 <code>transform</code> 的一个值。改变 <code>transform</code> 或 <code>opacity</code> 不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。 <code>transform</code> 使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此 <code>translate()</code> 更高效，可以缩短平滑动画的绘制时间。</p><p>当使用 <code>translate()</code> 时，元素仍然占据其原始空间（有点像 <code>position：relative</code> ），这与改变绝对定位不同。</p><h3 id="请阐述-z-index-属性，并说明如何形成层叠上下文（stacking-context"><a href="#请阐述-z-index-属性，并说明如何形成层叠上下文（stacking-context" class="headerlink" title="请阐述  z-index  属性，并说明如何形成层叠上下文（stacking context)"></a>请阐述  z-index  属性，并说明如何形成层叠上下文（stacking context)</h3><p>CSS 中的 <code>z-index</code> 属性控制重叠元素的垂直叠加顺序。 <code>z-index</code> 只能影响 <code>position</code> 值不是 <code>static</code> 的元素。</p><p>没有定义 <code>z-index</code> 的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。</p><p>层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的 <code>z-index</code> 值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的 <code>z-index</code> 值，元素 C 也永远不会在元素 B 之上. </p><p>每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如 <code>opacity</code> 小于 1， <code>filter</code> 不是 <code>none</code> ， <code>transform</code> 不是 <code>none</code> 。</p><h3 id="CSS渲染层？"><a href="#CSS渲染层？" class="headerlink" title="CSS渲染层？"></a>CSS渲染层？</h3><h4 id="什么是渲染层？"><a href="#什么是渲染层？" class="headerlink" title="什么是渲染层？"></a>什么是渲染层？</h4><p>处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的的渲染对象将形成多个渲染层，以体现它们的层叠关系。所以，对于满足形成层叠上下文条件的渲染对象，浏览器会自动为其创建新的渲染层。能够导致浏览器为其创建新的渲染层的，包括以下几类常见的情况：</p><ul><li>根元素 document</li><li>有明确的定位属性（relative、fixed、sticky、absolute）</li><li>opacity &lt; 1</li><li>有 CSS fliter 属性</li><li>有 CSS mask 属性</li><li>有 CSS mix-blend-mode 属性且值不为 normal</li><li>有 CSS transform 属性且值不为 none</li><li>backface-visibility 属性为 hidden</li><li>有 CSS reflection 属性</li><li>有 CSS column-count 属性且值不为 auto或者有 CSS column-width 属性且值不为 auto</li><li>当前有对于 opacity、transform、fliter、backdrop-filter 应用动画</li><li>overflow 不为 visible</li></ul><h4 id="合成层"><a href="#合成层" class="headerlink" title="合成层"></a>合成层</h4><p>满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。</p><p>那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里列举了一些常见的情况：</p><ul><li>3D transforms：translate3d、translateZ 等</li><li>video、canvas、iframe 等元素</li><li>通过 Element.animate() 实现的 opacity 动画转换</li><li>通过 СSS 动画实现的 opacity 动画转换</li><li>position: fixed</li><li>具有 will-change 属性</li><li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition</li></ul><p>我们可以使用<code>will-change</code>属性或者<code>transform: translateZ(0)</code>将 CPU 消耗高的渲染元素提升为一个新的合成层，从而开启 GPU 加速的。</p><p>这里值得注意的是，不少人会将这些合成层的条件和渲染层产生的条件混淆，这两种条件发生在两个不同的层处理环节，是完全不一样的。</p><p>每一个GraphicsLayer 处理自己所属的合成层（可能有多个渲染层），GraphicsLayer拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层（合成层）的位图。存储在共享内存中的位图将作为纹理上传到 GPU，最后由 GPU 将多个位图（多个合成层）进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上。</p><p><strong>总结：一个渲染层的内容发生了变化，会引起该渲染层所属的合成层的重绘或重排（有些操作不会引起重排），而一个合成层的内容的任何改变，都不会引起其他合成层的重绘和重排</strong></p><h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><p>一些交互复杂的玩法页面，存在持续变化位置的 animation 元素，我们最好是使用 transform 来实现而不是通过改变 left&#x2F;top 的方式。这样做的原因是：如果使用 left&#x2F;top 来实现位置变化，animation 节点和 Document 将被放到了同一个 GraphicsLayer 中进行渲染，持续的动画效果将导致整个 Document 不断地执行重绘，而使用 transform 的话，能够让 animation 节点被放置到一个独立合成层中进行渲染绘制，动画发生时不会影响到其它层。并且另一方面，动画会完全运行在 GPU 上，相比起 CPU 处理图层后再发送给显卡进行显示绘制来说，这样的动画往往更加流畅。</p><p>来源文章：<a href="https://juejin.cn/post/6844903966573068301">https://juejin.cn/post/6844903966573068301</a></p><h3 id="z-index属性在什么情况下会失效？"><a href="#z-index属性在什么情况下会失效？" class="headerlink" title="z-index属性在什么情况下会失效？"></a>z-index属性在什么情况下会失效？</h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p><p><strong>z-index属性在下列情况下会失效：</strong></p><ul><li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li><li>元素 position 属性为 static 。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li><li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li></ul><h3 id="CSS3中有哪些新特性"><a href="#CSS3中有哪些新特性" class="headerlink" title="CSS3中有哪些新特性"></a>CSS3中有哪些新特性</h3><ul><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadow、reflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ul><h3 id="替换元素的概念及计算规则"><a href="#替换元素的概念及计算规则" class="headerlink" title="替换元素的概念及计算规则"></a>替换元素的概念及计算规则</h3><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p><p>如<code>img、input、textarea、select</code>等元素，img 元素修改 src属性可以替换显示内容，同样，input元素修改 type 属性也可以改变显示内容。</p><p>替换元素除了内容可替换这一特性以外，还有以下特性：</p><ul><li><strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li><li><strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li><li><strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li><li><strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li></ul><p>替换元素的尺寸从内而外分为三类：</p><ul><li><strong>固有尺寸：</strong> 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li><li><strong>HTML尺寸：</strong> 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li><li><strong>CSS尺寸：</strong> 特指可以通过CSS的width和height或者max-width&#x2F;min-width和max-height&#x2F;min-height设置的尺寸，对应盒尺寸中的content box。</li></ul><p>这三层结构的计算规则具体如下：</p><p>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</p><p>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</p><p>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。</p><p>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</p><p>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</p><p>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p><h3 id="如何判断元素是否到达可视区域"><a href="#如何判断元素是否到达可视区域" class="headerlink" title="如何判断元素是否到达可视区域"></a>如何判断元素是否到达可视区域</h3><p>以图片显示为例：</p><ul><li><code>window.innerHeight</code> 是浏览器可视区的高度；</li><li><code>window.pageYOffset</code>是浏览器滚动的过的距离；</li><li><code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度</li><li>内容达到显示区域的条件：<code>img.offsetTop &lt; window.innerHeight + window.pageYOffset</code></li></ul><h3 id="line-height-的理解及其赋值方式"><a href="#line-height-的理解及其赋值方式" class="headerlink" title="line-height 的理解及其赋值方式"></a>line-height 的理解及其赋值方式</h3><p><strong>（1）line-height的概念：</strong></p><ul><li>line-height 指一行文本（包括文字、行内元素、行内块元素）的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li><li>line-height 和 height 都能撑开一个高度；</li></ul><p><strong>（2）line-height 的赋值方式：</strong></p><ul><li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 &#x3D; 27px</li><li>百分比：将计算后的值传递给后代</li></ul><h3 id="display-inline-block-什么时候会显示间隙？"><a href="#display-inline-block-什么时候会显示间隙？" class="headerlink" title="display:inline-block 什么时候会显示间隙？"></a>display:inline-block 什么时候会显示间隙？</h3><p><strong>原因：</strong>换行或空格会占据一定的位置</p><p><strong>解决</strong>：</p><p>水平间隙时：父元素设置<code>letter-spacing: -4px</code>或<code>word-spacing:-4px</code><br>垂直间隙时：子元素间设置 负值margin，如：<code>margin: -2px 0</code><br>上述两种情况通用：父元素设置 <code>font-size:0</code></p><h3 id="知道外边距重叠问题吗？如何解决？"><a href="#知道外边距重叠问题吗？如何解决？" class="headerlink" title="知道外边距重叠问题吗？如何解决？"></a>知道外边距重叠问题吗？如何解决？</h3><p><strong>问题描述：</strong></p><p>两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p><p><strong>计算原则：</strong></p><p>折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，那么就去最大者</li><li>如果是一正一负，就会正值减去负值的绝对值</li><li>两个都是负值时，用0减去两个中绝对值大的那个</li></ul><p><strong>解决办法：</strong></p><p>对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong></p><p>（1）兄弟之间重叠</p><ul><li>底部元素变为行内盒子：<code>display: inline-block</code></li><li>底部元素设置浮动：<code>float</code></li><li>底部元素的position的值为<code>absolute/fixed</code></li></ul><p>（2）父子之间重叠</p><ul><li>父元素加入：<code>overflow: hidden</code></li><li>父元素添加透明边框：<code>border:1px solid transparent</code></li><li>子元素变为行内盒子：<code>display: inline-block</code></li><li>子元素加入浮动属性或定位</li></ul><h4 id="什么是包含块，对于包含块的理解"><a href="#什么是包含块，对于包含块的理解" class="headerlink" title="什么是包含块，对于包含块的理解?"></a>什么是包含块，对于包含块的理解?</h4><p>包含块（containing block）就是元素用来计算和定位的一个框。</p><p>（1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</p><p>（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块级祖先元素的content box<br>边界形成。</p><p>（3）如果元素position:fixed，则“包含块”是“初始包含块”。</p><p>（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：</p><p>如果该祖先元素是纯inline元素，则规则略复杂：<br>•假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包<br>围盒就是内联元素的“包含块”；<br>•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥<br>否则，“包含块”由该祖先的padding box边界形成。</p><p>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</p><p>简单描述：默认情况下包含块就是离当前元素最近的块级祖先元素；<br>        对于开启了绝对定位的元素来说，包含块是离它最近的开启了定位（且position不为static）的祖先元素，<br>        如果所有的祖先元素都没有开启定位，则其包含块就是初始包含块。</p><h3 id="display、float、position的关系"><a href="#display、float、position的关系" class="headerlink" title="display、float、position的关系"></a>display、float、position的关系</h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制：</p><p><code>display:none</code> &gt;&gt;<code>position: absolute | fixed</code> &gt;&gt; <code>float: !none</code> &gt;&gt;  <code>element === root</code>  &gt;&gt; <code>display: other value</code> </p><h2 id="CSS响应式布局"><a href="#CSS响应式布局" class="headerlink" title="CSS响应式布局"></a>CSS响应式布局</h2><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p><a href="https://www.cnblogs.com/zhouqi666/articles/5322833.html">经典阮一峰1</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/07/flex-examples.html">经典阮一峰2</a></p><ul><li><p><strong>flex-flow</strong>: flex-direction 和 flex-wrap 的简写。</p><ul><li><p><strong>flex-direction</strong>：指定了flex容器的主轴方向</p><p><code>row</code>(默认) | <code>column</code> | <code>row-reverse</code> | <code>column-reverse</code></p><pre><code>row、row-reverse：主轴为x轴，子元素横向排列column、column-reverse：主轴为y轴，子元素纵向排列</code></pre></li><li><p><strong>flex-wrap：</strong>指定容器空间不够时的换行策略。</p><p><code>nowrap</code>（默认） | <code>wrap</code> | <code>wrap-reverse</code></p></li></ul></li><li><p><strong>flex</strong>：flex-grow、flex-shrink和flex-basis的简写。 </p><ul><li><p><strong>flex-grow：</strong>定义子元素<code>在主轴上</code>的<code>放大比例</code>，默认为0，即如果存在剩余空间，也不放大。</p><pre><code>某个子元素的分得的额外空间 = (容器剩余空间 / 所有子元素flex-grow属性值的和) * 该子元素flex-grow的属性值</code></pre></li><li><p><strong>flex-shrink：</strong>定义了子元素的缩小比例，默认为1，即如果空间不足，该子元素将缩小。</p><pre><code>设: 有 n 个子元素，空间分别为 W1、W2、W3 ··· Wn，flex-shrink的值分别为 S1、S2、S3 ··· S4，容器空间为 T则:某个子元素k的缩小的空间 = (sum(W1 ~ Wn) - T) * (Wk * Sk / sum(W1 * S1 ~ Wn * Sn))</code></pre></li><li><p><strong>flex-basis：</strong>定义了在分配多余空间之前，子元素占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>。当设定为长度值时分以下情况：</p><pre><code>当flex-direction为 row 或 row-reverse时，等同于 width当flex-direction为 column 或 column-reverse时，等同于 height</code></pre></li></ul></li><li><p><strong>justify-content、justify-self：</strong>定义了如何分配父容器主轴方向的子元素之间及其周围的空间。</p><p> <img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img"></p></li><li><p><strong>align-items、align-self：</strong>定义子元素在交叉轴上如何对齐。</p><p> <img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img"></p></li><li><p><strong>align-content：</strong>多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><p> <img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img"></p></li></ul><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">经典阮一峰</a></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>header<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>side-bar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>side-bar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>footer<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>content<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token number">.</span>container&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">600</span>px<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">1000</span>px<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 将容器分为由 10 * 6 的网格 */</span>        <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">6</span>, <span class="token number">1</span>fr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span>, <span class="token number">1</span>fr<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token property">grid-template-areas</span><span class="token punctuation">:</span>             <span class="token string">"hd hd hd hd hd hd hd hd hd hd"</span>            <span class="token string">"sb sb ct ct ct ct ct ct ct ct"</span>            <span class="token string">"sb sb ct ct ct ct ct ct ct ct"</span>            <span class="token string">"sb sb ct ct ct ct ct ct ct ct"</span>            <span class="token string">"sb sb ct ct ct ct ct ct ct ct"</span>            <span class="token string">"ft ft ft ft ft ft ft ft ft ft"</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>header&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/** 第一种，使用名称*/</span>        <span class="token property">grid-area</span><span class="token punctuation">:</span> hd<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/**第二、三、四种作用原理相同*/</span>        <span class="token comment" spellcheck="true">/** 第二种，指定坐标，四个值分别为左上角x,y坐标，右下角y,x坐标*/</span>        <span class="token property">grid-area</span><span class="token punctuation">:</span> <span class="token number">1</span> / <span class="token number">1</span> / <span class="token number">2</span> / <span class="token number">11</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/** 第三种*/</span>        <span class="token property">grid-column</span><span class="token punctuation">:</span> <span class="token number">1</span> / <span class="token number">11</span><span class="token punctuation">;</span>        <span class="token property">grid-row</span><span class="token punctuation">:</span> <span class="token number">1</span> / <span class="token number">2</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/**第四种*/</span>        <span class="token property">grid-column-start</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token property">grid-column-end</span><span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">;</span>        <span class="token property">grid-row-start</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token property">grid-row-end</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>side-bar&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>        <span class="token property">grid-area</span><span class="token punctuation">:</span> sb<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>footer&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>        <span class="token property">grid-area</span><span class="token punctuation">:</span> ft<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">.</span>content&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>        <span class="token property">grid-area</span><span class="token punctuation">:</span> ct<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p><img src="https://files.catbox.moe/4rf4tk.png"></p><h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p><strong>示例</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">    #box &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>        <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>        <span class="token property">transition</span><span class="token punctuation">:</span> transform <span class="token number">1</span>s ease-in <span class="token number">1</span>s<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    #<span class="token property">box</span><span class="token punctuation">:</span>hover &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token number">180</span>deg<span class="token punctuation">)</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">.5</span>, <span class="token number">.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/3/163c42601ede4b6e~tplv-t2oaga2asx-watermark.awebp" alt="image"></p><p><strong>属性</strong></p><p><code>transition: property | duration | timing-function | delay</code></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>transition-property</td><td>规定设置过渡效果的 CSS 属性的名称</td></tr><tr><td>transition-duration</td><td>规定完成过渡效果需要多少秒或毫秒</td></tr><tr><td>transition-timing-function</td><td>规定速度效果的贝塞尔曲线</td></tr><tr><td>transition-delay</td><td>定义过渡效果的延迟时间</td></tr></tbody></table><h3 id="animation、keyframes"><a href="#animation、keyframes" class="headerlink" title="animation、keyframes"></a>animation、keyframes</h3><p>animation和keyframes总是一起出现，keyframes用来描述一个动画，animation用来定义如何使用一个动画</p><p><strong>示例</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>box<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">    <span class="token number">.</span>box &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>        <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">15</span>px solid black<span class="token punctuation">;</span>        <span class="token property">animation</span><span class="token punctuation">:</span> changebox <span class="token number">1</span>s ease-in-out <span class="token number">1</span>s infinite alternate running forwards<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token number">.</span><span class="token property">box</span><span class="token punctuation">:</span>hover &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">animation-play-state</span><span class="token punctuation">:</span> paused<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token atrule"><span class="token rule">@keyframes</span> changebox &amp;#123<span class="token punctuation">;</span></span>        <span class="token number">10%</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">50%</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">80</span>px<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">70%</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">15</span>px solid yellow<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>        <span class="token number">100%</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">180</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">180</span>px<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/6/3/163c4261137cc7df~tplv-t2oaga2asx-watermark.awebp" alt="image"></p><p><strong>属性</strong></p><p><code>animation: name | duration | timing-function | delay | iteration-count | direction | play-state | fill-mode</code></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>用来调用@keyframes定义好的动画，与@keyframes定义的动画名称一致</td></tr><tr><td>duration</td><td>指定元素播放动画所持续的时间</td></tr><tr><td>timing-function</td><td>规定速度效果的速度曲线，是针对每一个小动画所在时间范围的变换速率</td></tr><tr><td>delay</td><td>定义在浏览器开始执行动画之前等待的时间，值整个animation执行之前等待的时间</td></tr><tr><td>iteration-count</td><td>定义动画的播放次数，可选具体次数或者无限(infinite)</td></tr><tr><td>direction</td><td>设置动画播放方向：normal(按时间轴顺序),reverse(时间轴反方向运行),alternate(轮流，即来回往复进行),alternate-reverse(动画先反运行再正方向运行，并持续交替运行)</td></tr><tr><td>play-state</td><td>控制元素动画的播放状态，通过此来控制动画的暂停和继续，两个值：running(继续)，paused(暂停)</td></tr><tr><td>fill-mode</td><td>控制动画结束后元素的样式，有四个值：none(回到动画没开始时的状态)，forwards(动画结束后动画停留在结束状态)，backwords(动画回到第一帧的状态)，both(根据animation-direction轮流应用forwards和backwards规则)，注意与iteration-count不要冲突(动画执行无限次)</td></tr></tbody></table><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><h3 id="CSS选择器的权重和优先级"><a href="#CSS选择器的权重和优先级" class="headerlink" title="CSS选择器的权重和优先级"></a>CSS选择器的权重和优先级</h3><p><strong>权重</strong></p><ul><li>从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0</li></ul><p><strong>优先级</strong></p><ul><li>权重相同，写在后面的覆盖前面的</li><li>使用 <code>!important</code> 达到最大优先级，都使用 <code>!important</code> 时，权重大的优先级高</li></ul><h3 id="浏览器是怎样解析CSS选择器的？"><a href="#浏览器是怎样解析CSS选择器的？" class="headerlink" title="浏览器是怎样解析CSS选择器的？"></a>浏览器是怎样解析CSS选择器的？</h3><p><strong>CSS选择器的解析是从右向左解析的，为了避免对所有元素进行遍历</strong>。因为如果从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p><h3 id="CSS选择器有哪些？"><a href="#CSS选择器有哪些？" class="headerlink" title="CSS选择器有哪些？"></a>CSS选择器有哪些？</h3><h4 id="直接选择器"><a href="#直接选择器" class="headerlink" title="直接选择器"></a>直接选择器</h4><h5 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h5><pre class=" language-css"><code class="language-css">*&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token property">padding</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h5 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h5><pre class=" language-css"><code class="language-css">p&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h5 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h5><pre class=" language-css"><code class="language-css"><span class="token number">.</span>warning&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h5 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h5><pre class=" language-css"><code class="language-css">#warning&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h5 id="属性选取器"><a href="#属性选取器" class="headerlink" title="属性选取器"></a>属性选取器</h5><p><strong>[attribute]</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选择所有具有 foo 属性的元素 */</span>[foo]&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p><strong>[attribute&#x3D;value]</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选择 foo 属性值为 abc 的元素*/</span>[foo=abc]&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p><em><em>[attribute~&#x3D;value]、[attribute</em>&#x3D;value]</em>*</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/**    e1: foo = "abc def"    e2: foo = "abcdef"*/</span><span class="token comment" spellcheck="true">/* 选择 foo 属性值中带有 abc 这个单词的元素，可以选中 e1 */</span>[foo~=abc]&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择 foo 属性值中带有 abc 的元素，可以选中 e1, e2*/</span>[foo*=abc]&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p><strong>[attribute^&#x3D;value]、[attribute|&#x3D;value]、[attribute$&#x3D;value]</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选择 foo 属性值以 abc 开头的元素*/</span>[foo^=abc]&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择 foo 属性值以 abc 开头的元素，且与后面部分只能用连字符连接如：foo = "abc"、foo = "abc-def"、foo = "abc-def-ghi"*/</span>[foo|=abc]&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择 foo 属性值以 abc 结尾的元素*/</span>[foo$=abc]&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h4 id="文档结构选择器"><a href="#文档结构选择器" class="headerlink" title="文档结构选择器"></a>文档结构选择器</h4><h5 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h5><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选择 ul 元素内的所有 li 元素 */</span>ul li&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h5 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h5><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选择 父元素为 li、爷元素为 ul 的 p 元素 */</span> ul>li>p&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h5 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h5><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选择紧邻在 h1 元素后的 p 元素，注意只选择一个 */</span>h<span class="token number">1</span>+p&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h5 id="一般兄弟选择器"><a href="#一般兄弟选择器" class="headerlink" title="一般兄弟选择器"></a>一般兄弟选择器</h5><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选择前面有 h1 元素后的 p 元素，注意可选择多个 */</span> h<span class="token number">1</span>~p&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><h5 id="root-根元素伪类"><a href="#root-根元素伪类" class="headerlink" title=":root 根元素伪类"></a>:root 根元素伪类</h5><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 一般情况下相当于 html 元素 */</span><span class="token punctuation">:</span>root&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">background-color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h5 id="子元素相关伪类"><a href="#子元素相关伪类" class="headerlink" title="子元素相关伪类"></a>子元素相关伪类</h5><p><strong>:nth-child(n)、:nth-last-child(n) 、:first-child、:last-child</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选中div元素的第一个子节点 */</span><span class="token property">div</span> <span class="token punctuation">:</span><span class="token function">nth-child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选中div元素的最后一个子节点 */</span><span class="token property">div</span> <span class="token punctuation">:</span><span class="token function">nth-last-child</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选中div元素的第一个子节点 */</span><span class="token property">div</span> <span class="token punctuation">:</span>first-child&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选中div元素的最后一个子节点 */</span><span class="token property">div</span> <span class="token punctuation">:</span>last-child&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p><strong>:nth-of-type(n) 、:nth-last-of-type(n)、:first-of-type、:last-of-type</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选中div元素的第二个子节点，且该子节点的类型为 p */</span>div <span class="token property">p</span><span class="token punctuation">:</span><span class="token function">nth-of-type</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选中div元素的倒数第二个子节点，且该子节点的类型为 p */</span>div <span class="token property">p</span><span class="token punctuation">:</span><span class="token function">nth-last-of-type</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选中div元素的第一个 p 子节点 */</span>div <span class="token property">p</span><span class="token punctuation">:</span>first-of-type&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选中div元素的最后一个 p 子节点 */</span>div <span class="token property">p</span><span class="token punctuation">:</span>last-of-type&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p><strong>:only-child</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选中div元素的唯一一个子元素 */</span><span class="token property">div</span> <span class="token punctuation">:</span>only-child&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p><strong>:empty</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选中没有子元素的div元素 */</span><span class="token property">div</span> <span class="token punctuation">:</span>empty&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p><strong>:only-of-type</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选中div的唯一一个 p 子元素*/</span>div <span class="token property">p</span><span class="token punctuation">:</span>only-of-type&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h5 id="元素状态相关选择器"><a href="#元素状态相关选择器" class="headerlink" title="元素状态相关选择器"></a>元素状态相关选择器</h5><p><strong>:link、:active、:hover、:visited、:focus、:enable、:disabled、:checked、:not()</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选择地址未被访问过的 a 标签，通过 a 标签的 href 属性和浏览器历史记录的匹配结果实现，而且是响应式的 */</span><span class="token property">a</span><span class="token punctuation">:</span>link&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择正在处于激活状态的 a 标签 */</span><span class="token property">a</span><span class="token punctuation">:</span>active&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择处于鼠标指针位置上的 a 标签 */</span><span class="token property">a</span><span class="token punctuation">:</span>hover&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择地址已被访问过的 a 标签，与 :link 刚好互斥 */</span><span class="token property">a</span><span class="token punctuation">:</span>visited&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择获得焦点的 input 元素 */</span><span class="token property">input</span><span class="token punctuation">:</span>focus&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择处于启用状态的 input 元素，即未使用 disabled 属性的 input 元素 */</span><span class="token property">input</span><span class="token punctuation">:</span>enabled&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择处于禁用状态的 input 元素，即使用了 disabled 属性的 input 元素 */</span><span class="token property">input</span><span class="token punctuation">:</span>disabled&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选择每一个选中的 input[type="radio"]、input[type="checkbox"]和 option */</span>*<span class="token punctuation">:</span>checked&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 反向选择 */</span><span class="token punctuation">:</span><span class="token function">not</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span></code></pre><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>注意，伪类选择器是一个冒号、伪元素选择器是两个冒号</p><p><strong>::first-line、::first-letter、::selection</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 选中所有 p 元素的第一行文字 */</span><span class="token property">p</span><span class="token punctuation">:</span><span class="token punctuation">:</span>first-line&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选中所有 p 元素的第一个字母 */</span><span class="token property">p</span><span class="token punctuation">:</span><span class="token punctuation">:</span>first-letter&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 选中所有 p 元素的被选择的文字 */</span><span class="token property">p</span><span class="token punctuation">:</span><span class="token punctuation">:</span>selection&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p><strong>::before、::after</strong></p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* 在 p 元素前插入元素 */</span><span class="token property">p</span><span class="token punctuation">:</span><span class="token punctuation">:</span>before&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">'hello'</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 在 p 元素后插入元素 */</span><span class="token property">p</span><span class="token punctuation">:</span><span class="token punctuation">:</span>after&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">'。'</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><h2 id="CSS浏览器相关"><a href="#CSS浏览器相关" class="headerlink" title="CSS浏览器相关"></a>CSS浏览器相关</h2><h3 id="标准盒模型和怪异（IE）盒模型"><a href="#标准盒模型和怪异（IE）盒模型" class="headerlink" title="标准盒模型和怪异（IE）盒模型"></a>标准盒模型和怪异（IE）盒模型</h3><ol><li>标准盒模型<br>标准盒模型（W3C盒子模型），设置的width或height是对 实际内容（content）的width或height进行设置，内容周围的border和padding另外设置，即盒子模型的width（height）&#x3D;设置的content的宽高+padding+border+margin<br>注：除内容content外，其他为上下左右都有</li></ol><p><img src="/../../Desktop/img/20200902173247902.png"></p><ol start="2"><li><p>怪异盒模型（IE盒子模型）</p><p>怪异盒模型（IE盒子模型），设置的width或height是对 实际内容（content）+内边距（padding）+边框（border）之和的width和height进行设置的，其盒模型的width（height）&#x3D;设置的width（height）+外边距margin</p></li></ol><p><img src="/../../Desktop/img/20200902173305473.png"></p><p>可使用box-sizing: content-box | border-box 来进行切换，非IE浏览器默认为标准盒模型</p><h3 id="主流浏览器内核私有属性css前缀是什么？"><a href="#主流浏览器内核私有属性css前缀是什么？" class="headerlink" title="主流浏览器内核私有属性css前缀是什么？"></a>主流浏览器内核私有属性css前缀是什么？</h3><ul><li>mozilla 内核 （firefox,flock 等）    -moz</li><li>webkit  内核 （safari,chrome 等）   -webkit</li><li>opera   内核 （opera 浏览器）        -o</li><li>trident 内核 （ie 浏览器）           -ms</li></ul><h3 id="CSS引入的方式有哪些？使用Link和-import有什么区别？"><a href="#CSS引入的方式有哪些？使用Link和-import有什么区别？" class="headerlink" title="CSS引入的方式有哪些？使用Link和@import有什么区别？"></a>CSS引入的方式有哪些？使用Link和@import有什么区别？</h3><ol><li>link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义RSS，定义 rel 连接属性等作用，无兼容性，支持使用javascript改变样式；而@import是CSS提供的，只能用于加载CSS，不支持使用 javascript 改变样式；</li><li>页面被加载的时，link会被同时加载，而@import引用的CSS会等到页面加载完再加载；</li><li>import是CSS2.1提出的，CSS2.1以下浏览器不支持，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。</li></ol><h3 id="浏览器的渲染原理？"><a href="#浏览器的渲染原理？" class="headerlink" title="浏览器的渲染原理？"></a>浏览器的渲染原理？</h3><ul><li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的</li><li>然后对 CSS 进行解析，生成CSSOM规则树。</li><li>根据DOM树和CSSOM规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM元素相对应，但这种对应关系不是一对一的，不可见的DOM元素不会被插入渲染树。还有一些DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示在屏幕上，绘制使用UI基础组件。</li></ul><h3 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h3><p>在讨论回流与重绘之前，我们要知道：</p><ol><li>浏览器使用流式布局模型 (Flow Based Layout)。</li><li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</li><li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li><li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。</li></ol><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为<strong>回流</strong>。</p><p>会导致回流的操作：</p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li><li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li><li>查询某些属性或调用某些方法</li></ul><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为<strong>重绘</strong>。</p><h4 id="浏览器优化"><a href="#浏览器优化" class="headerlink" title="浏览器优化"></a>浏览器优化</h4><p>浏览器对回流和重绘做了以下的优化：</p><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p><p>当访问以下属性或方法时，浏览器会立刻清空队列：</p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>width</code>、<code>height</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li></ul><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p><h4 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h4><p><strong>CSS</strong></p><ul><li>避免使用<code>table</code>布局。</li><li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li><li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li></ul><p><strong>JavaScript</strong></p><ul><li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li><li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li><li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流&#x2F;重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h2 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h2><h3 id="对-CSS-工程化的理解"><a href="#对-CSS-工程化的理解" class="headerlink" title="对 CSS 工程化的理解"></a>对 CSS 工程化的理解</h3><p>CSS 工程化是为了解决以下问题：</p><ol><li><strong>宏观设计</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li><li><strong>编码优化</strong>：怎样写出更好的 CSS？</li><li><strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</li><li><strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li></ol><p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p><ul><li>预处理器：Less、 Sass 等；</li><li>重要的工程化插件： PostCss；</li><li>Webpack loader 等 。</li></ul><p>基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：</p><p><strong>（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？</strong></p><p>预处理器，其实就是CSS世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：</p><p><img src="/../../Desktop/img/5ee2df9500016ef112620300.png" alt="image"></p><p>那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：</p><ol><li>宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的CSS文件实现复用；</li><li>编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；</li><li>可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。</li></ol><p>这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：</p><ul><li>嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；</li><li>支持定义 css 变量；</li><li>提供计算函数；</li><li>允许对代码片段进行 extend 和 mixin；</li><li>支持循环语句的使用；</li><li>支持将 CSS 文件模块化，实现复用。</li></ul><p><strong>（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</strong></p><p>PostCss 仍然是一个对CSS进行解析和处理的工具，它会对CSS做这样的事情：</p><p><img src="/../../Desktop/img/5ee2df9e0001fdcf12580304.png" alt="img"></p><p>它和预处理器的不同就在于，预处理器处理的是类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。</p><p>PostCss 在业务中的使用场景非常多：</p><ul><li>提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li><li>当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> 插件可以帮助我们自动增加浏览器前缀；</li><li>允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li></ul><p><strong>（3）Webpack 能处理 CSS 吗？如何实现？</strong></p><p>Webpack 能处理 CSS 吗：</p><ul><li><strong>Webpack 在裸奔的状态下，是不能处理 CSS 的</strong>，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；</li><li>Webpack 在 loader 的辅助下，是可以处理 CSS 的。</li></ul><p>如何用 Webpack 实现对 CSS 的处理：</p><ul><li><p>Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</p></li><li><p>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：</p></li><li><ul><li>css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；</li><li>style-loader：创建style标签，把 CSS 内容写入标签。</li></ul></li></ul><p>在实际使用中，<strong>css-loader 的执行顺序一定要安排在 style-loader 的前面</strong>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p><h3 id="使用-CSS-预处理的优缺点分别是什么？"><a href="#使用-CSS-预处理的优缺点分别是什么？" class="headerlink" title="使用 CSS 预处理的优缺点分别是什么？"></a>使用 CSS 预处理的优缺点分别是什么？</h3><p>优点：</p><ul><li>提高 CSS 可维护性。</li><li>易于编写嵌套选择器。</li><li>引入变量，增添主题功能。可以在不同的项目中共享主题文件。</li><li>通过混合（Mixins）生成重复的 CSS。</li><li>将代码分割成多个文件。不进行预处理的 CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。</li></ul><p>缺点：</p><ul><li>需要预处理工具。</li><li>重新编译的时间可能会很慢。</li></ul><h3 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ol><li><p><strong>值变量</strong></p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@color<span class="token punctuation">:</span></span> <span class="token hexcode">#999</span><span class="token punctuation">;</span><span class="token variable">@bgColor<span class="token punctuation">:</span></span> skyblue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不要添加引号</span><span class="token variable">@width<span class="token punctuation">:</span></span> <span class="token number">50%</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap &amp;#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">@color</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token variable">@bgColor</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@width</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span>#wrap &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#999</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> skyblue<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>以 <code>@</code> 开头 定义变量，并且使用时 直接 键入 <code>@</code>名称。</p><p>在平时工作中，我们就可以把 常用的变量 封装到一个文件中，这样利于代码组织维护。</p><pre class=" language-less"><code class="language-less"><span class="token variable">@lightPrimaryColor<span class="token punctuation">:</span></span> <span class="token hexcode">#c5cae9</span><span class="token punctuation">;</span><span class="token variable">@textPrimaryColor<span class="token punctuation">:</span></span> <span class="token hexcode">#fff</span><span class="token punctuation">;</span><span class="token variable">@accentColor<span class="token punctuation">:</span></span> <span class="token function">rgb</span><span class="token punctuation">(</span><span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">137</span><span class="token punctuation">,</span> <span class="token number">185</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">@primaryTextColor<span class="token punctuation">:</span></span> <span class="token hexcode">#646464</span><span class="token punctuation">;</span><span class="token variable">@secondaryTextColor<span class="token punctuation">:</span></span> <span class="token hexcode">#000</span><span class="token punctuation">;</span><span class="token variable">@dividerColor<span class="token punctuation">:</span></span> <span class="token hexcode">#b6b6b6</span><span class="token punctuation">;</span><span class="token variable">@borderColor<span class="token punctuation">:</span></span> <span class="token hexcode">#dadada</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>选择器变量</strong></p><p>让 选择器 变成 动态</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@mySelector<span class="token punctuation">:</span></span> #wrap<span class="token punctuation">;</span><span class="token variable">@Wrap<span class="token punctuation">:</span></span> wrap<span class="token punctuation">;</span>@&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>mySelector&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//变量名 必须使用大括号包裹</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#999</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token number">.</span>@&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>Wrap&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span><span class="token hexcode">#ccc</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>#@&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>Wrap&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span><span class="token hexcode">#666</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#wrap&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#999</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.wrap&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span><span class="token hexcode">#ccc</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span><span class="token hexcode">#666</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>属性变量</strong></p><p>可减少代码书写量</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@borderStyle<span class="token punctuation">:</span></span> border<span class="token operator">-</span>style<span class="token punctuation">;</span><span class="token variable">@Soild<span class="token punctuation">:</span></span>solid<span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>  @&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>borderStyle&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token punctuation">:</span> <span class="token variable">@Soild</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//变量名 必须使用大括号包裹</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#wrap&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">border-style</span><span class="token punctuation">:</span>solid<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>url 变量</strong></p><p>项目结构改变时，修改其变量即可。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@images<span class="token punctuation">:</span></span> <span class="token string">"../img"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//需要加引号</span>body &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url">url("@&amp;#123;images&amp;#125;/dog.png")</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//变量名 必须使用大括号包裹</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>body &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token url">url("../img/dog.png")</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>声明变量</strong></p><p>有点类似于 下面的 混合方法</p><ul><li>结构: @name: { 属性: 值 ;};</li><li>使用：@name();</li></ul><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@background<span class="token punctuation">:</span></span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>    <span class="token variable">@background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token variable">@Rules<span class="token punctuation">:</span></span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> solid <span class="token number">1</span>px red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token mixin-usage function">#con&amp;#123</span><span class="token punctuation">;</span>  <span class="token variable">@Rules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#con&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> solid <span class="token number">1</span>px red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>变量运算</strong></p><p>不得不提的是，Less 的变量运算完全超出我的期望，十分强大。</p><ul><li>加减法时，以第一个数据的单位为基准</li><li>乘除法时 注意单位一定要统一</li></ul><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@width<span class="token punctuation">:</span></span><span class="token number">300</span>px<span class="token punctuation">;</span><span class="token variable">@color<span class="token punctuation">:</span></span><span class="token hexcode">#222</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token variable">@width-20</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token variable">@width-20</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token variable">@width-20</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span><span class="token variable">@color</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token variable">@color</span> <span class="token operator">+</span> <span class="token hexcode">#111</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#wrap&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">280</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">1400</span>px<span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span><span class="token hexcode">#444</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span><span class="token hexcode">#333</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>变量作用域</strong></p><p>一句话理解就是：<strong>就近原则</strong></p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@var<span class="token punctuation">:</span></span> <span class="token variable">@a</span><span class="token punctuation">;</span><span class="token variable">@a<span class="token punctuation">:</span></span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap &amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@var</span><span class="token punctuation">;</span>  <span class="token variable">@a<span class="token punctuation">:</span></span> <span class="token number">9%</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#wrap &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">9%</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>用变量去定义变量</strong></p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@fnord<span class="token punctuation">:</span></span>  <span class="token string">"I am fnord."</span><span class="token punctuation">;</span><span class="token variable">@var<span class="token punctuation">:</span></span>    <span class="token string">"fnord"</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap::after&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token variable">@@var</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将@var替换为其值 content:@fnord;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#<span class="token property">wrap</span><span class="token punctuation">:</span><span class="token punctuation">:</span>after&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">"I am fnord."</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><ol><li><p><strong>&amp; 的妙用</strong></p><p>&amp; ：代表的上一层选择器的名字，此例便是<code>header</code>。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span>#header&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  &amp;<span class="token punctuation">:</span>after&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is more!"</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.title&amp;#123</span><span class="token punctuation">;</span>    <span class="token property">font-weight</span><span class="token punctuation">:</span>bold<span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  &amp;_content&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//理解方式：直接把 &amp; 替换成 #header</span>    <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#<span class="token property">header</span><span class="token punctuation">:</span><span class="token punctuation">:</span>after&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is more!"</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#header .title&amp;#123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//嵌套了</span>  <span class="token property">font-weight</span><span class="token punctuation">:</span>bold<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#header_content&amp;#123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//没有嵌套！</span>    <span class="token property">margin</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>媒体查询</strong></p><p>在以往的工作中，我们使用 媒体查询，都要把一个元素 分开写</p><pre class=" language-less"><code class="language-less">#wrap&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">500</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token variable">@media</span> screen and <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span><span class="token number">768</span>px<span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>Less 提供了一个十分便捷的方式</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//something...</span>    <span class="token variable">@media</span> screen&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token variable">@media</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span><span class="token number">768</span>px<span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>          <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token variable">@media</span> tv &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>      <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">2000</span>px<span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token variable">@media</span> screen and <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span><span class="token number">768</span>px<span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>      <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>   &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token variable">@media</span> tv&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">2000</span>px<span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>唯一的缺点就是 每一个元素都会编译出自己 <code>@media</code> 声明，并不会合并。</p></li><li><p><strong>实战技巧</strong></p><p>可以借助 Less 在元素中，去定义自己的私有样式。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// something..</span>  &amp;<span class="token number">.</span>show&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.show&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><pre class=" language-less"><code class="language-less">const main = document<span class="token number">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>main<span class="token number">.</span>classList<span class="token number">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"show"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果：</p><pre class=" language-less"><code class="language-less">#main<span class="token number">.</span>show&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span>block<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.show&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//会被覆盖。</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="混合方法"><a href="#混合方法" class="headerlink" title="混合方法"></a>混合方法</h4><ol><li><p><strong>无参数方法</strong></p><p>方法犹如 声明的集合，使用时 直接键入名称即可。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span>card &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于 .card()</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#f6f6f6</span><span class="token punctuation">;</span>    <span class="token property">-webkit-box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">1</span>px <span class="token number">2</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">1</span>px <span class="token number">2</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.card</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于.card();</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#wrap&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#f6f6f6</span><span class="token punctuation">;</span>  <span class="token property">-webkit-box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">1</span>px <span class="token number">2</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">1</span>px <span class="token number">2</span>px <span class="token function">rgba</span><span class="token punctuation">(</span><span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">151</span><span class="token punctuation">,</span> <span class="token number">.58</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>其中 <code>.card</code> 与 <code>.card()</code> 是等价的。 个人建议，为了避免代码混淆，应写成 :</p><pre class=" language-less"><code class="language-less"><span class="token number">.</span><span class="token function">card</span><span class="token punctuation">(</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//something...</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>要点：</p><ul><li><code>.</code> 与 <code>#</code> 皆可作为方法前缀。</li><li>方法后写不写 <code>()</code> 看个人习惯。</li></ul></li><li><p><strong>默认参数方法</strong></p><ul><li>Less可以使用默认参数，如果没有传参数，那么将使用默认参数。</li><li><code>@arguments</code> 犹如JS中的 <code>arguments</code> 指代的是全部参数。</li><li>传的参数中必须带着单位。</li></ul><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span><span class="token function">border</span><span class="token punctuation">(</span><span class="token variable">@a<span class="token punctuation">:</span></span><span class="token number">10</span>px<span class="token punctuation">,</span><span class="token variable">@b<span class="token punctuation">:</span></span><span class="token number">50</span>px<span class="token punctuation">,</span><span class="token variable">@c<span class="token punctuation">:</span></span><span class="token number">30</span>px<span class="token punctuation">,</span><span class="token variable">@color<span class="token punctuation">:</span></span><span class="token hexcode">#000</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token number">1</span>px <span class="token variable">@color</span><span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token variable">@arguments</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指代的是全部参数</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">.border</span><span class="token punctuation">(</span><span class="token number">0</span>px<span class="token punctuation">,</span><span class="token number">5</span>px<span class="token punctuation">,</span><span class="token number">30</span>px<span class="token punctuation">,</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//必须带着单位</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">.border</span><span class="token punctuation">(</span><span class="token number">0</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#content&amp;#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.border</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//等价于 .border()</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token number">1</span>px red<span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span><span class="token number">0</span>px<span class="token punctuation">,</span><span class="token number">5</span>px<span class="token punctuation">,</span><span class="token number">30</span>px<span class="token punctuation">,</span>red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token number">1</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">0</span>px <span class="token number">50</span>px <span class="token number">30</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#content&amp;#123</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token number">1</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">10</span>px <span class="token number">50</span>px <span class="token number">30</span>px <span class="token hexcode">#000</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>方法的匹配模式</strong></p><p>与 面向对象中的多态 很相似</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span><span class="token function">triangle</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span><span class="token variable">@width<span class="token punctuation">:</span></span><span class="token number">20</span>px<span class="token punctuation">,</span><span class="token variable">@color<span class="token punctuation">:</span></span><span class="token hexcode">#000</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">border-color</span><span class="token punctuation">:</span>transparent  transparent <span class="token variable">@color</span> transparent <span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.triangle</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span><span class="token variable">@width<span class="token punctuation">:</span></span><span class="token number">20</span>px<span class="token punctuation">,</span><span class="token variable">@color<span class="token punctuation">:</span></span><span class="token hexcode">#000</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">border-color</span><span class="token punctuation">:</span>transparent <span class="token variable">@color</span> transparent  transparent <span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.triangle</span><span class="token punctuation">(</span>bottom<span class="token punctuation">,</span><span class="token variable">@width<span class="token punctuation">:</span></span><span class="token number">20</span>px<span class="token punctuation">,</span><span class="token variable">@color<span class="token punctuation">:</span></span><span class="token hexcode">#000</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">border-color</span><span class="token punctuation">:</span><span class="token variable">@color</span> transparent  transparent  transparent <span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.triangle</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span><span class="token variable">@width<span class="token punctuation">:</span></span><span class="token number">20</span>px<span class="token punctuation">,</span><span class="token variable">@color<span class="token punctuation">:</span></span><span class="token hexcode">#000</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">border-color</span><span class="token punctuation">:</span>transparent  transparent  transparent <span class="token variable">@color</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.triangle</span><span class="token punctuation">(</span><span class="token variable">@_</span><span class="token punctuation">,</span><span class="token variable">@width<span class="token punctuation">:</span></span><span class="token number">20</span>px<span class="token punctuation">,</span><span class="token variable">@color<span class="token punctuation">:</span></span><span class="token hexcode">#000</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>    <span class="token property">border-width</span><span class="token punctuation">:</span> <span class="token variable">@width</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">.triangle</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token number">50</span>px<span class="token punctuation">,</span> <span class="token hexcode">#999</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">border-color</span><span class="token punctuation">:</span>transparent  transparent  transparent <span class="token hexcode">#999</span><span class="token punctuation">;</span>  <span class="token property">border-style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>  <span class="token property">border-width</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>要点</p><ul><li>第一个参数 <code>left</code> 要会找到方法中匹配程度最高的，如果匹配程度相同，将全部选择，并存在着样式覆盖替换。</li><li>如果匹配的参数 是变量，则将会匹配，如 <code>@_</code> 。</li></ul></li><li><p><strong>方法的命名空间</strong></p><p>让方法更加规范</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span>#<span class="token function">card</span><span class="token punctuation">(</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#723232</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">.d</span><span class="token punctuation">(</span><span class="token variable">@w<span class="token punctuation">:</span></span><span class="token number">300</span>px<span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> <span class="token variable">@w</span><span class="token punctuation">;</span>                <span class="token mixin-usage function">#a</span><span class="token punctuation">(</span><span class="token variable">@h<span class="token punctuation">:</span></span><span class="token number">300</span>px<span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token variable">@h</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//可以使用上一层传进来的方法</span>        &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">#card > .d > #a</span><span class="token punctuation">(</span><span class="token number">100</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 父元素不能加 括号</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">#card .d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#con&amp;#123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不得单独使用命名空间的方法</span>    <span class="token comment" spellcheck="true">//.d() 如果前面没有引入命名空间 #card ，将会报错</span>        #card<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于 #card();</span>    <span class="token number">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token number">20</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//必须先引入 #card</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#wrap&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">300</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#con&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>要点</p><ul><li>在 CSS 中<code>&gt;</code> 选择器，选择的是 儿子元素，就是 必须与父元素 有直接血源的元素。</li><li>在引入命令空间时，如使用 <code>&gt;</code> 选择器，父元素不能加 括号。</li><li>不得单独使用命名空间的方法 必须先引入命名空间，才能使用 其中方法。</li><li>子方法 可以使用上一层传进来的方法</li></ul></li><li><p><strong>方法的条件筛选</strong></p><p>Less 没有 if else，可是它有 <code>when</code></p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span>#card&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// and 运算符 ，相当于 与运算 &amp;&amp;，必须条件全部符合才会执行</span>    <span class="token number">.</span><span class="token function">border</span><span class="token punctuation">(</span><span class="token variable">@width</span><span class="token punctuation">,</span><span class="token variable">@color</span><span class="token punctuation">,</span><span class="token variable">@style</span><span class="token punctuation">)</span> when <span class="token punctuation">(</span><span class="token variable">@width</span>><span class="token number">100</span>px<span class="token punctuation">)</span> <span class="token function">and</span><span class="token punctuation">(</span><span class="token variable">@color</span>=<span class="token hexcode">#999</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">border</span><span class="token punctuation">:</span><span class="token variable">@style</span> <span class="token variable">@color</span> <span class="token variable">@width</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// not 运算符，相当于 非运算 !，条件为 不符合才会执行</span>    <span class="token number">.</span><span class="token function">background</span><span class="token punctuation">(</span><span class="token variable">@color</span><span class="token punctuation">)</span> when not <span class="token punctuation">(</span><span class="token variable">@color</span>>=<span class="token hexcode">#222</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">background</span><span class="token punctuation">:</span><span class="token variable">@color</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// , 逗号分隔符：相当于 或运算 ||，只要有一个符合条件就会执行</span>    <span class="token number">.</span><span class="token function">font</span><span class="token punctuation">(</span><span class="token variable">@size<span class="token punctuation">:</span></span><span class="token number">20</span>px<span class="token punctuation">)</span> when <span class="token punctuation">(</span><span class="token variable">@size</span>><span class="token number">50</span>px<span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token variable">@size</span>&lt;<span class="token number">100</span>px<span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> <span class="token variable">@size</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">#card>.border</span><span class="token punctuation">(</span><span class="token number">200</span>px<span class="token punctuation">,</span><span class="token hexcode">#999</span><span class="token punctuation">,</span>solid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">#card .background</span><span class="token punctuation">(</span><span class="token hexcode">#111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">#card > .font</span><span class="token punctuation">(</span><span class="token number">40</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span>solid <span class="token hexcode">#999</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  <span class="token property">background</span><span class="token punctuation">:</span><span class="token hexcode">#111</span><span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">40</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>要点</p><ul><li>比较运算有： &gt; &gt;&#x3D; &#x3D; &#x3D;&lt; &lt;。</li><li>&#x3D; 代表的是等于</li><li>除去关键字 true 以外的值都被视为 false：</li></ul></li><li><p><strong>数量不定的参数</strong></p><p>如果你希望你的方法接受数量不定的参数，你可以使用… ，犹如 ES6 的扩展运算符。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span><span class="token function">boxShadow</span><span class="token punctuation">(</span><span class="token number">...</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token variable">@arguments</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.textShadow</span><span class="token punctuation">(</span><span class="token variable">@a</span><span class="token punctuation">,</span><span class="token number">...</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">text-shadow</span><span class="token punctuation">:</span> <span class="token variable">@arguments</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">.boxShadow</span><span class="token punctuation">(</span><span class="token number">1</span>px<span class="token punctuation">,</span><span class="token number">4</span>px<span class="token punctuation">,</span><span class="token number">30</span>px<span class="token punctuation">,</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">.textShadow</span><span class="token punctuation">(</span><span class="token number">1</span>px<span class="token punctuation">,</span><span class="token number">4</span>px<span class="token punctuation">,</span><span class="token number">30</span>px<span class="token punctuation">,</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">box-shadow</span><span class="token punctuation">:</span> <span class="token number">1</span>px <span class="token number">4</span>px <span class="token number">30</span>px red<span class="token punctuation">;</span>  <span class="token property">text-shadow</span><span class="token punctuation">:</span> <span class="token number">1</span>px <span class="token number">4</span>px <span class="token number">30</span>px red<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>方法使用important！</strong></p><p>使用方法 非常简单，在方法名后 加上关键字即可。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span>border&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> solid <span class="token number">1</span>px red<span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">50</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">.border</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token important">!important</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span>#main &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> solid <span class="token number">1</span>px red <span class="token important">!important</span><span class="token punctuation">;</span>    <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">50</span>px <span class="token important">!important</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>循环方法</strong></p><p>Less 并没有提供 for 循环功能，但这也难不倒 聪明的程序员，使用递归去实现。 下面是官网中的一个 Demo，模拟了生成栅格系统。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span><span class="token function">generate-columns</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token mixin-usage function">.generate-columns</span><span class="token punctuation">(</span><span class="token variable">@n</span><span class="token punctuation">,</span> <span class="token variable">@i<span class="token punctuation">:</span></span> <span class="token number">1</span><span class="token punctuation">)</span> when <span class="token punctuation">(</span><span class="token variable">@i</span> =&lt; <span class="token variable">@n</span><span class="token punctuation">)</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.column-@&amp;#123</span><span class="token punctuation">;</span>i&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token variable">@i</span> <span class="token operator">*</span> <span class="token number">100%</span> <span class="token operator">/</span> <span class="token variable">@n</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.generate-columns</span><span class="token punctuation">(</span><span class="token variable">@n</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token variable">@i</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token number">.</span>column<span class="token operator">-</span><span class="token number">1</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">25%</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.column-2 &amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">50%</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.column-3 &amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">75%</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.column-4 &amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>属性拼接方法</strong></p><p><code>+_</code> 代表的是 空格；<code>+</code> 代表的是 逗号。</p><ul><li>逗号</li></ul><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span><span class="token function">boxShadow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">box-shadow+</span><span class="token punctuation">:</span> inset <span class="token number">0</span> <span class="token number">0</span> <span class="token number">10</span>px <span class="token hexcode">#555</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.main &amp;#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.boxShadow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">box-shadow+</span><span class="token punctuation">:</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">20</span>px black<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token number">.</span>main &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">box-shadow</span><span class="token punctuation">:</span> inset <span class="token number">0</span> <span class="token number">0</span> <span class="token number">10</span>px <span class="token hexcode">#555</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">20</span>px black<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><ul><li>空格</li></ul><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span><span class="token function">Animation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">transform+_</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.main &amp;#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.Animation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">transform+_</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token number">15</span>deg<span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span><span class="token number">.</span>main &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token number">15</span>deg<span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>实战技巧</strong></p><p>下面是官网中的一个非常赞的 Demo</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span><span class="token function">average</span><span class="token punctuation">(</span><span class="token variable">@x</span><span class="token punctuation">,</span> <span class="token variable">@y</span><span class="token punctuation">)</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token variable">@average<span class="token punctuation">:</span></span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">@x</span> <span class="token operator">+</span> <span class="token variable">@y</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>div &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.average</span><span class="token punctuation">(</span><span class="token number">16</span>px<span class="token punctuation">,</span> <span class="token number">50</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 方法</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token variable">@average</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用返回值</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>div &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">33</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li></ol><p>可以说 Less 是一门优雅编程语言。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>extend 是 Less 的一个伪类。它可继承 所匹配声明中的全部样式。</p><ol><li><p><strong>extend 关键字的使用</strong></p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span>animation&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">transition</span><span class="token punctuation">:</span> all <span class="token number">.3</span>s ease<span class="token operator">-</span>out<span class="token punctuation">;</span>    <span class="token mixin-usage function">.hide&amp;#123</span><span class="token punctuation">;</span>      <span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>    &amp;<span class="token punctuation">:</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token number">.</span>animation<span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#con&amp;#123</span><span class="token punctuation">;</span>    &amp;<span class="token punctuation">:</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token number">.</span>animation <span class="token number">.</span>hide<span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token number">.</span>animation<span class="token punctuation">,</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">transition</span><span class="token punctuation">:</span> all <span class="token number">.3</span>s ease<span class="token operator">-</span>out<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.animation .hide , #con&amp;#123</span><span class="token punctuation">;</span>    <span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">scale</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>all 全局搜索替换</strong></p><p>使用选择器匹配到的 全部声明。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main &amp;#123</span><span class="token punctuation">;</span>  &amp;<span class="token punctuation">:</span>after &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is good!"</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap:extend</span><span class="token punctuation">(</span>#main all<span class="token punctuation">)</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#main<span class="token punctuation">,</span>#wrap&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main:after, #wrap:after &amp;#123</span><span class="token punctuation">;</span>    <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">"Less is good!"</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>减少代码的重复性</strong></p><p>从表面 看来，extend 与 方法 最大的差别，就是 extend 是同个选择器共用同一个声明，而 方法 是使用自己的声明，这无疑 增加了代码的重复性。</p><p>方法示例 与上面的 extend 进行对比：</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token number">.</span>Method&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  &amp;<span class="token punctuation">:</span>after &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>      <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is good!"</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#main&amp;#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.Method</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.Method</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成的 CSS */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  &amp;<span class="token punctuation">:</span>after&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is good!"</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>  &amp;<span class="token punctuation">:</span>after&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"Less is good!"</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>要点</strong></p><p><em>翻译官网</em></p><ul><li>选择器和扩展之间 是允许有空格的：pre:hover :extend(div pre).</li><li>可以有多个扩展: pre:hover:extend(div pre):extend(.bucket tr) - 注意这与 pre:hover:extend(div pre, .bucket tr)一样。</li><li>这是不可以的，扩展必须在最后 : pre:hover:extend(div pre).nth-child(odd)。</li><li>如果一个规则集包含多个选择器，所有选择器都可以使用extend关键字。</li></ul><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol><li>导入 less 文件 可省略后缀</li></ol><pre class=" language-less"><code class="language-less">import <span class="token string">"main"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//等价于</span>import <span class="token string">"main.less"</span><span class="token punctuation">;</span></code></pre><ol><li><code>@import</code> 的位置可随意放置</li></ol><pre class=" language-less"><code class="language-less">#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">15</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token variable">@import</span> <span class="token string">"style"</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>reference</strong></p><p>Less 中 最强大的特性 使用 引入的 Less 文件，但不会 编译它。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@import</span> <span class="token punctuation">(</span>reference<span class="token punctuation">)</span> <span class="token string">"bootstrap.less"</span><span class="token punctuation">;</span> <span class="token mixin-usage function">#wrap:extend</span><span class="token punctuation">(</span><span class="token number">.</span>navbar all<span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>翻译官网：</p><blockquote><p>使用@import (reference)导入外部文件，但不会添加 把导入的文件 编译到最终输出中，只引用。</p></blockquote></li><li><p><strong>once</strong></p><blockquote><p>@import语句的默认行为。这表明相同的文件只会被导入一次，而随后的导入文件的重复代码都不会解析。</p></blockquote><pre class=" language-less"><code class="language-less"><span class="token variable">@import</span> <span class="token punctuation">(</span>once<span class="token punctuation">)</span> <span class="token string">"foo.less"</span><span class="token punctuation">;</span><span class="token variable">@import</span> <span class="token punctuation">(</span>once<span class="token punctuation">)</span> <span class="token string">"foo.less"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// this statement will be ignored</span></code></pre></li><li><p><strong>multiple</strong></p><blockquote><p>使用@import (multiple)允许导入多个同名文件。</p></blockquote><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token comment" spellcheck="true">// file: foo.less</span><span class="token number">.</span>a &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// file: main.less</span><span class="token variable">@import</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span> <span class="token string">"foo.less"</span><span class="token punctuation">;</span><span class="token variable">@import</span> <span class="token punctuation">(</span>multiple<span class="token punctuation">)</span> <span class="token string">"foo.less"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token number">.</span>a &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.a &amp;#123</span><span class="token punctuation">;</span>  <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li></ol><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ol><li><p><strong>判断类型</strong></p><ul><li>isnumber</li></ul><blockquote><p>判断给定的值 是否 是一个数字。</p></blockquote><pre class=" language-less"><code class="language-less"><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token hexcode">#ff0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// false</span><span class="token function">isnumber</span><span class="token punctuation">(</span>blue<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// false</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// true</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token number">56</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// true</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token number">7.8%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// true</span><span class="token function">isnumber</span><span class="token punctuation">(</span>keyword<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// false</span><span class="token function">isnumber</span><span class="token punctuation">(</span><span class="token url">url(...)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span></code></pre><ul><li>iscolor</li></ul><blockquote><p>判断给定的值 是否 是一个颜色。</p></blockquote><ul><li>isurl</li></ul><blockquote><p>判断给定的值 是否 是一个 url 。</p></blockquote></li><li><p><strong>颜色操作</strong></p><ul><li>saturate</li></ul><blockquote><p>增加一定数值的颜色饱和度。</p></blockquote><ul><li>lighten</li></ul><blockquote><p>增加一定数值的颜色亮度。</p></blockquote><ul><li>darken</li></ul><blockquote><p>降低一定数值的颜色亮度。</p></blockquote><ul><li>fade</li></ul><blockquote><p>给颜色设定一定数值的透明度。</p></blockquote><ul><li>mix</li></ul><blockquote><p>根据比例混合两种颜色。</p></blockquote></li><li><p><strong>数学函数</strong></p><ul><li>ceil</li></ul><blockquote><p>向上取整。</p></blockquote><ul><li>floor</li></ul><blockquote><p>向下取整。</p></blockquote><ul><li>percentage</li></ul><blockquote><p>将浮点数转换为百分比字符串。</p></blockquote><ul><li>round</li></ul><blockquote><p>四舍五入。</p></blockquote><ul><li>sqrt</li></ul><blockquote><p>计算一个数的平方根。</p></blockquote><ul><li>abs</li></ul><blockquote><p>计算数字的绝对值，原样保持单位。</p></blockquote><ul><li>pow</li></ul><blockquote><p>计算一个数的乘方。</p></blockquote></li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li><p><strong>注释</strong></p><ul><li>&#x2F;* *&#x2F; CSS原生注释，会被编译在 CSS 文件中。</li><li>&#x2F;  &#x2F; Less提供的一种注释，不会被编译在 CSS 文件中。</li></ul></li><li><p><strong>避免编译</strong></p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span>~<span class="token string">'calc(300px-30px)'</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span>#main&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span><span class="token function">calc</span><span class="token punctuation">(</span><span class="token number">300</span>px<span class="token operator">-</span><span class="token number">30</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>结构： <code>~&#39; 值 &#39;</code></p></li><li><p><strong>变量拼串</strong></p><p>在平时工作中，这种需求 太常见了。 在下面例子中， 实现了不同的 transtion-delay、animation、@keyframes</p><pre class=" language-less"><code class="language-less"><span class="token number">.</span><span class="token function">judge</span><span class="token punctuation">(</span><span class="token variable">@i</span><span class="token punctuation">)</span> <span class="token function">when</span><span class="token punctuation">(</span><span class="token variable">@i</span>=<span class="token number">1</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token variable">@size<span class="token punctuation">:</span></span><span class="token number">15</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.judge</span><span class="token punctuation">(</span><span class="token variable">@i</span><span class="token punctuation">)</span> <span class="token function">when</span><span class="token punctuation">(</span><span class="token variable">@i</span>><span class="token number">1</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token variable">@size<span class="token punctuation">:</span></span><span class="token number">16</span>px<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">.loopAnimation</span><span class="token punctuation">(</span><span class="token variable">@i</span><span class="token punctuation">)</span> when <span class="token punctuation">(</span><span class="token variable">@i</span>&lt;<span class="token number">16</span><span class="token punctuation">)</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token mixin-usage function">.circle:nth-child</span><span class="token punctuation">(</span>@&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>i&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>      <span class="token mixin-usage function">.judeg</span><span class="token punctuation">(</span><span class="token variable">@i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token property">border-radius</span><span class="token punctuation">:</span><span class="token variable">@size</span> <span class="token variable">@size</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token property">animation</span><span class="token punctuation">:</span> ~<span class="token string">"circle-@&amp;#123;i&amp;#125;"</span> <span class="token variable">@duration</span> infinite <span class="token variable">@ease</span><span class="token punctuation">;</span>      <span class="token property">transition-delay</span><span class="token punctuation">:</span>~<span class="token string">"@&amp;#123;i&amp;#125;ms"</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  <span class="token variable">@keyframes</span> ~<span class="token string">"circle-@&amp;#123;i&amp;#125;"</span> &amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// do something...</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">.loopAnimation</span><span class="token punctuation">(</span><span class="token variable">@i</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p>结构： <code>~&quot;字符@&#123;变量&#125;字符&quot;</code>;</p></li><li><p><strong>使用 JS</strong></p><p>因为 Less 是由 JS 编写，所以 Less 有一得天独厚的特性：代码中使用 Javascript 。</p><pre class=" language-less"><code class="language-less"><span class="token comment" spellcheck="true">/* Less */</span><span class="token variable">@content<span class="token punctuation">:</span></span>`<span class="token string">"aaa"</span><span class="token number">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>`<span class="token punctuation">;</span><span class="token mixin-usage function">#randomColor&amp;#123</span><span class="token punctuation">;</span>  <span class="token variable">@randomColor<span class="token punctuation">:</span></span> ~<span class="token string">"rgb(`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`,`Math.round(Math.random() * 256)`)"</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> ~<span class="token string">"`Math.round(Math.random() * 100)`px"</span><span class="token punctuation">;</span>  &amp;<span class="token punctuation">:</span>after&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>      <span class="token property">content</span><span class="token punctuation">:</span><span class="token variable">@content</span><span class="token punctuation">;</span>  &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> ~<span class="token string">"`window.innerHeight`px"</span><span class="token punctuation">;</span>  <span class="token property">alert</span><span class="token punctuation">:</span>~<span class="token string">"`alert(1)`"</span><span class="token punctuation">;</span>  <span class="token mixin-usage function">#randomColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token variable">@randomColor</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 生成后的 CSS */</span><span class="token comment" spellcheck="true">// 弹出 1</span>#wrap&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> 随机值（<span class="token number">0</span>~<span class="token number">100</span>）px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">743</span>px<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//由电脑而异</span>  <span class="token property">background</span><span class="token punctuation">:</span> 随机颜色<span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span><span class="token mixin-usage function">#wrap::after&amp;#123</span><span class="token punctuation">;</span>  <span class="token property">content</span><span class="token punctuation">:</span><span class="token string">"AAA"</span><span class="token punctuation">;</span>&amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack知识点</title>
      <link href="/2022/07/29/webpack-zhi-shi-dian/"/>
      <url>/2022/07/29/webpack-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h3 id="CommonJS和ES6-Module"><a href="#CommonJS和ES6-Module" class="headerlink" title="CommonJS和ES6 Module"></a>CommonJS和ES6 Module</h3><ol><li><p><strong>动态和静态</strong><br>CommonJS 与 ES6 Module最本质的区别在于前者对<strong>模块依赖的解决</strong>是“动态的”，而后者是“静 态的”。在这里“动态”的含义是，模块依赖关系的建立发生在代码运行阶段;而“静态”则是模块依赖关系的建立发生在代码编译阶段。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//CommonJS</span><span class="token operator">...</span>some script<span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./person.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token comment" spellcheck="true">//ES6 Module</span><span class="token keyword">import</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>name<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">from</span> <span class="token string">'./person.js'</span> </code></pre><p>我们可以看出，CommonJS可以在代码的任何位置引入模块，而ES6 Module只能在文件的开头导入模块。因此CommonJS的实际导入行为是发生在代码执行时的，因此是动态的，而ES6 Module则会在代码执行前就导入模块（代码编译阶段），因此是静态的。因此ES6 Module相比CommonJS有如下优点：</p><ul><li>死代码检测和排除。我们可以用静态分析工具检测出哪些模块没有被调用过。<br>比如，在引入工具类库时，工程中往往只用到了其中一部分组件或接口，但有可能会将其代码完整地加载进来。未被调用到的模块代码永远不会被执行，也就成为了死代码。通过静态分析可以在打包时去掉这些未曾使用过的模块，以减小打包资源体积。</li><li>模块变量类型检查。JavaScript属于动态类型语言，不会在代码执行前检查类型错误（比如对一个字符串类型的值进行函数调用)。ES6 Module的静态模块结构有助于确保模块之间传递的值或接口类型是正确的。</li><li>编译器优化。在 CommonJS等动态模块系统中，无论采用哪种方式，本质上导入的都是一个对象，而ES6 Module支持直接导入变量，减少了引用层级，程序效率更高。</li></ul></li><li><p><strong>拷贝与动态映射</strong></p><p>在导入一个模块时，对于CommonJS来说获取的是一份<strong>导出值的拷贝（浅拷贝）</strong>；而在ES6Module中则是<strong>值的动态映射</strong>，并且这个映射是<strong>只读</strong>的。</p><p>CommonJS中的值拷贝:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// calculator.js .</span><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    count<span class="token punctuation">:</span> count<span class="token punctuation">,</span>    add<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a， b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        count <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">var</span> count <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./calculator.js'</span><span class="token punctuation">)</span> <span class="token punctuation">.</span>count <span class="token punctuation">;</span> <span class="token keyword">var</span> add <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./calculator.js'</span><span class="token punctuation">)</span> <span class="token punctuation">.</span>add<span class="token punctuation">;</span>console<span class="token punctuation">.</span> <span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//0</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span>，<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>console<span class="token punctuation">.</span> log <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0 (calculator.js中变量值的改变不会对拷贝值造成影响)</span>count <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span> log <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 (拷贝的值可以更改)</span></code></pre><p>ES6 Module的值动态映射：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// calculator.js .</span><span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">let</span> add <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">export</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> count<span class="token punctuation">,</span> add <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">import</span> <span class="token punctuation">(</span> count， add <span class="token punctuation">)</span> <span class="token keyword">from</span> <span class="token string">'./calculator.js'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span> <span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0 (对calculator.js 中count 值的映射)</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span>，<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>console<span class="token punctuation">.</span> <span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 (实时反映calculator.js中count值的变化)</span>count <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//不可更改，会抛出SyntaxBrror: "count" is read-only</span></code></pre><p>上面的例子展示了ES6 Module中导入的变量其实是对原有值的动态映射。index.js<br>中的count是对calculator.js中的count值的实时反映，当我们通过调用add函数更改了<br>calculator.js中count值时，index.js 中count的值也随之变化。<br>我们不可以对ES6 Module导入的变量进行更改，可以将这种映射关系理解为一面<br>镜子，从镜子里我们可以实时观察到原有的事物，但是并不可以操纵镜子中的影像。</p></li><li><p><strong>循环依赖</strong></p><p>循环依赖是指模块A依赖于模块B，同时模块B依赖于模块A。一般来说工程中应该尽量避免循环依赖的产生，因为从软件设计的角度来说，单向的依赖关系更加清晰，而循环依赖则会带来一定的复杂度。</p><p>CommonJS中循环依赖的例子:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// foo.js</span><span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./bar.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'value of bar:'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token string">'This is foo.js'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// bar.js</span><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./foo.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'value of foo:'</span>， foo<span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token string">'This is bar.js'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// index.js</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./foo.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>理想状态下我们希望在控制台上输出。</p><pre class=" language-javascript"><code class="language-javascript">value <span class="token keyword">of</span> foo<span class="token punctuation">:</span> This is foo<span class="token punctuation">.</span>jsvalue <span class="token keyword">of</span> bar<span class="token punctuation">:</span> This is bar<span class="token punctuation">.</span>js</code></pre><p>而当我们运行上面的代码时，实际输出却是:</p><pre class=" language-javascript"><code class="language-javascript">value <span class="token keyword">of</span> foo<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>value <span class="token keyword">of</span> bar<span class="token punctuation">:</span> This is bar<span class="token punctuation">.</span>is</code></pre><p>为什么foo的值会是一个空对象呢?让我们从头梳理一下代码的实际执行顺序。</p><ol><li>index.js导入了foo.js， 此时开始执行foo.js中的代码。</li><li>foo.js 的第一句导入了bar.js， 这时foo.js不会继续向下执行，而是进入了bar.js内部。</li><li>在bar.js中又对foo.js进行了require，这里产生了循环依赖。需要注意的是，执行权并不会再交回foo.js，而是<strong>直接取其导出值</strong>，也就是module.exports。 但由于foo.js未执行完毕，导出值在这时为默认的空对象，因此当bar.js执行到打印语句时，我们看到控制台中的value of foo就是一个空对象。</li></ol><p>我们再从Webpack的实现角度来看，将上面例子打包后，bundle.js 中有这样一段代码非常重要:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// The require function </span><span class="token keyword">function</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span>moduleId<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>installedModules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> installedModules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span><span class="token punctuation">.</span>exports<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建模块，我们可以看见，模块的安装是先于模块的执行的</span>    <span class="token keyword">var</span> module <span class="token operator">=</span> installedModules<span class="token punctuation">[</span>moduleId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        i<span class="token punctuation">:</span> moduleId<span class="token punctuation">,</span>        l<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        exports<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>当index.js引用了foo.js之后，相当于执行了这个__webpack_require__ 函数, 初始化了一个module对象并放入installedModules中。当bar.js再次引用foo.js时，又执行了该函数，但这次是直接从installedModules里面取值，此时它的module.exports是一个空对象。这就解释了上面在第3步看到的现象。</p><p>接下来让我们使用ES6 Module的方式重写上面的例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//foo.js</span><span class="token keyword">import</span> bar <span class="token keyword">from</span> <span class="token string">' ./bar.js'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'value of bar:'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">'This is foo.js'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// bar.js</span><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">' ./foo.js'</span> <span class="token punctuation">;</span>console<span class="token punctuation">.</span>log<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">'value of foo:'</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">'This is bar.js'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">' ./foo.js'</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//执行结果如下:</span>value <span class="token keyword">of</span> foo<span class="token punctuation">:</span> undefinedvalue <span class="token keyword">of</span> bar<span class="token punctuation">:</span> This is bar<span class="token punctuation">.</span>js</code></pre><p>很遗憾，在bar.js中同样无法得到foo.js正确的导出值，只不过和CommonJS默认导出一个个空对象不同，这里获取到的是undefined。<br>上面我们谈到，在导入一个模块时，CommonJS获取到的是值的拷贝，ES6 Module则是动态映射，那么我们能否利用ES6Module的特性使其支持循环依赖呢?请看下面这个例子:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//index.js</span><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">' ./foo.js'</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'index.js'</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">// foo.js</span><span class="token keyword">import</span> bar <span class="token keyword">from</span> <span class="token string">'./bar.js'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span>log <span class="token punctuation">(</span>invoker <span class="token operator">+</span> <span class="token string">' invokes foo.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token string">'foo.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> foo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// bar.js</span><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">'./foo.js'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在这里时，foo还是没有值的</span><span class="token keyword">let</span> invoked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span>invoker<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>invoked<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        invoked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span>log <span class="token punctuation">(</span>invoker <span class="token operator">+</span> <span class="token string">' invokes bar.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">'bar.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//执行到这里时，由于现在的执行权在index.js上，所以foo函数已成功导出，所以可以调用</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> bar<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上面代码的执行结果如下:</span>index<span class="token punctuation">.</span>js invokes foo<span class="token punctuation">.</span>jsfoo<span class="token punctuation">.</span>js invokes bar<span class="token punctuation">.</span>jsbar<span class="token punctuation">.</span>js invokes foo<span class="token punctuation">.</span>js</code></pre><p>由上面的例子可以看出，ES6 Module的特性使其可以更好地支持循环依赖，只是需要由开发者来保证当导入的值被使用时已经设置好正确的导出值。</p></li></ol><h3 id="模块打包原理"><a href="#模块打包原理" class="headerlink" title="模块打包原理"></a>模块打包原理</h3><p>面对工程中成百上千个模块，Webpack 究竟是如何将它们有序地组织在一起，并按照我们预想的顺序运行在浏览器上的呢？下面我们将从原理上进行探究:</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">const</span> calculator <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./calculator.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">const</span> sum <span class="token operator">=</span> calculator<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sum'</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// calculator.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     add<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>上面的代码经过Webpack打包后将会成为如下的形式（为了易读性这里只展示代码的大体结构）：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 立即执行匿名函数 </span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>modules<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//模块缓存</span>    <span class="token keyword">var</span> installedModules <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 实现require</span>    <span class="token keyword">function</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span>moduleId<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token operator">...</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 执行入口模块的加载 </span>        <span class="token keyword">return</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span>__webpack_require__<span class="token punctuation">.</span>s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// modules：以key-value的形式储存所有被打包的模块 </span>        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> __webpack_require__<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 打包入口</span>            module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">__webpack_require__</span><span class="token punctuation">(</span><span class="token string">"3qiv"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token string">"3qiv"</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> __webpack_require__<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// index.js内容</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        jkzz<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// calculator.js 内容</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这是一个最简单的Webpack 打包结果（bundle），但已经可以清晰地展示出它是如何将具有依赖关系的模块串联在一起的。上面的 bundle 分为以下几个部分：</p><ol><li>最外层立即执行匿名函数。它用来包裹整个 bundle，并构成自身的作用域。 </li><li>installedModules 对象。每个模块只在第一次被加载的时候执行，之后其导出值就被存储到这个对象里面，当再次被加载的时候直接从这里取值，而不会重新执行。</li><li><em>_webpack_require</em>_ 函数。对模块加载的实现，在浏览器中可以通过调用 <em>_webpack_require</em>_(module_id) 来完成模块导入。</li><li>modules 对象。工程中所有产生了依赖关系的模块都会以 key-value 的形式放在 这里。key 可以理解为一个模块的 id，由数字或者一个很短的 hash 字符串构成； value 则是由一个匿名函数包裹的模块实体，匿名函数的参数则赋予了每个模块导出和导入的能力。</li></ol><p>接下来让我们看看一个 bundle 是如何在浏览器中执行的。 </p><ol><li>在最外层的匿名函数中会初始化浏览器执行环境，包括定义 installedModules 对<br>象、<em>_webpack_require</em>_ 函数等，为模块的加载和执行做一些准备工作。</li><li>加载入口模块。每个 bundle 都有且只有一个入口模块，在上面的示例中，<br>index.js 是入口模块，在浏览器中会从它开始执行。</li><li>执行模块代码。如果执行到了 module.exports 则记录下模块的导出值；如果中<br>间遇到 require 函数（准确地说是 __webpack_require_<em>），则会暂时交出执行权，进入 __webpack_require</em>_ 函数体内进行加载其他模块的逻辑。</li><li>在 <em>_webpack_require</em>_ 中会判断即将加载的模块是否存在于 installedModules 中。如果存在则直接取值，否则回到第 3 步，执行该模块的代码来获取导出值。</li><li>所有依赖的模块都已执行完毕，最后执行权又回到入口模块。当入口模块的代码执行到结尾，也就意味着整个 bundle 运行结束。 不难看出，第 3 步和第 4 步是一个递归的过程。Webpack 为每个模块创造了一个可以导出和导入模块的环境，但本质上并没有修改代码的执行逻辑，因此代码执行的顺序与模块加载的顺序是完全一致的，这就是Webpack 模块打包的奥秘。</li></ol><h3 id="资源输入输出"><a href="#资源输入输出" class="headerlink" title="资源输入输出"></a>资源输入输出</h3><h4 id="资源处理流程"><a href="#资源处理流程" class="headerlink" title="资源处理流程"></a>资源处理流程</h4><p>从上面我们已经了解到，Webpack 会从入口文件开始检索，并将具有依赖关系的模块生成一棵依赖树，最终得到一个chunk。由这个chunk得到的打包产物我们一般称之为bundle。entry、chunk、 bundle 的关系如图所示：</p><img src="https://files.catbox.moe/c1b0di.png" style="zoom:100%;margin-left:0" /><h4 id="配置资源入口"><a href="#配置资源入口" class="headerlink" title="配置资源入口"></a>配置资源入口</h4><h5 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h5><p>Webpack通过context和entry这两个配置项来共同决定入口文件的路径。在配置<br>入口时，实际上做了两件事:</p><ul><li>确定入口模块位置（context + entry），告诉Webpack从哪里开始进行打包。</li><li>定义chunk name。 如果工程只有一个入口，那么默认其chunk name为“main”；如果工程有多个入口，我们需要为每个入口定义chunk name,来作为该chunk的唯一标识。</li></ul><p>context可以理解为资源入口的路径前缀，在配置时要求必须使用绝对路径的形式。<br>请看下面两个例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//以下两种配置达到的效果相同，入口都为&lt;工程根路径>/src/scripts/index.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    context<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./src'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     entry<span class="token punctuation">:</span> <span class="token string">'./scripts/index.js'</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    context<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./src/scripts'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     entry<span class="token punctuation">:</span> <span class="token string">'./index.js'</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>配置 context 的主要目的是让 entry 的编写更加简洁，尤其是在多入口的情况下。 context 可以省略，默认值为当前工程的根目录。</p><p>entry 与 context 只能为字符串不同，entry 的配置可以有多种形式：字符串、数组、对象、 函数。可以根据不同的需求场景来选择。</p><ol><li>字符串类型入口，直接传入文件路径：</li></ol><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>     output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>     mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span> </code></pre><ol start="2"><li>数组类型入口<br> 传入一个数组的作用是将多个资源预先合并，在打包时Webpack 会将数组中的最后一个元素作为实际的入口路径。如：</li></ol><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token string">'babel-polyfill'</span><span class="token punctuation">,</span>         <span class="token string">'./src/index.js'</span>    <span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>上面的配置等同于：<span class="token comment" spellcheck="true">//webpack.config.js </span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// index.js</span><span class="token keyword">import</span> <span class="token string">'babel-polyfill'</span><span class="token punctuation">;</span></code></pre><ol start="3"><li><p>对象类型入口如果想要定义<strong>多入口</strong> ， 则必须使用对象的形式。<br>对象的属性名（key）是 chunk name，属性值（value）是入口路径。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// chunk name为index，入口路径为./src/index.js </span>        index<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>         <span class="token comment" spellcheck="true">// chunk name为lib，入口路径为./src/lib.js </span>        lib<span class="token punctuation">:</span> <span class="token string">'./src/lib.js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对象的属性值为字符串或数组。如：</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        index<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'babel-polyfill'</span><span class="token punctuation">,</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>         lib<span class="token punctuation">:</span> <span class="token string">'./src/lib.js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span> </code></pre><p>在使用字符串或数组定义单入口时，并没有办法更改 chunk name，只能为默认的 “main”。在使用对象来定义多入口时，则必须为每一个入口定义 chunk name。</p></li><li><p>函数类型入口</p><p>用函数定义入口时，只要返回上面介绍的任何配置形式即可，如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 返回一个字符串型的入口</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 返回一个对象型的入口 </span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     entry<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        index<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'babel-polyfill'</span><span class="token punctuation">,</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>         lib<span class="token punctuation">:</span> <span class="token string">'./src/lib.js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>传入一个函数的优点在于我们可以在函数体里添加一些动态的逻辑来获取工程的入 口。另外，函数也支持返回一个 Promise 对象来进行异步操作。</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 模拟异步操作 </span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'./src/index.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre></li></ol><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p><strong>单页应用</strong></p><p>单页应用好处是只会产生一个 JS 文件，依赖关系清晰。即所有模块都打包到一起，当应用的规模上升到一定程度之后会导致产生的资源体积过大，降低用户的页面渲染速度，而且当代码发生一点改变并打包上传后，用户的缓存便失效而不得不重新下载整个资源，这对于页面的加载也是不利的。<br>解决单页应用所引发的性能问题可以使用vendor来分割业务代码和第三方依赖，如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    context<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'./src'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>       entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        app<span class="token punctuation">:</span> <span class="token string">'./src/app.js'</span><span class="token punctuation">,</span>        vendor<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'react'</span><span class="token punctuation">,</span> <span class="token string">'react-dom'</span><span class="token punctuation">,</span> <span class="token string">'react-router'</span><span class="token punctuation">]</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>通过这样的配置，app.js 产生的 bundle 将只包含业务模块，其依赖的第三方模块将会被抽取出来生成一个新的 bundle，由于 vendor 仅仅包含第三方模块，这部分不会经常变动，因此可以有效地利用客户端缓存，在用户后续请求页面时会加快整体的渲染速度。</p><p><strong>多页应用</strong></p><p>对于多页应用的场景，为了尽可能减小资源的体积，我们希望每个页面都只加载各自必要的逻辑，而不是将所有页面打包到同一个 bundle 中。因此每个页面都需要有一个独立的 bundle，这种情形我们使用多入口来实现。请看下面的例子：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        pageA<span class="token punctuation">:</span> <span class="token string">'./src/pageA.js'</span><span class="token punctuation">,</span>         pageB<span class="token punctuation">:</span> <span class="token string">'./src/pageB.js'</span><span class="token punctuation">,</span>         pageC<span class="token punctuation">:</span> <span class="token string">'./src/pageC.js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>在上面的配置中，入口与页面是一一对应的关系，这样每个 HTML 只要引入各自的 JS 就可以加载其所需要的模块。另外，对于多页应用的场景，我们同样可以使用提取 vendor 的方法，将各个页面之间的公共模块进行打包。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        pageA<span class="token punctuation">:</span> <span class="token string">'./src/pageA.js'</span><span class="token punctuation">,</span>         pageB<span class="token punctuation">:</span> <span class="token string">'./src/pageB.js'</span><span class="token punctuation">,</span>         pageC<span class="token punctuation">:</span> <span class="token string">'./src/pageC.js'</span><span class="token punctuation">,</span>         vendor<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'react'</span><span class="token punctuation">,</span> <span class="token string">'react-dom'</span><span class="token punctuation">]</span> <span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>可以看到，我们将 react 和 react-dom 打包进了 vendor，之后再配置 optimization.splitChunks，将它们从各个页面中提取出来，生成单独的 bundle 即可。</p><h4 id="配置资源出口"><a href="#配置资源出口" class="headerlink" title="配置资源出口"></a>配置资源出口</h4><h5 id="配置项-1"><a href="#配置项-1" class="headerlink" title="配置项"></a>配置项</h5><p>接着我们来看资源输出相关的配置,所有与出口相关的配置都集中在 output 对象里。例如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> require <span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token string">'./ src/app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>        path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span><span class="token string">'assets'</span> <span class="token punctuation">)</span> <span class="token punctuation">,</span>        publicPath<span class="token punctuation">:</span> <span class="token string">'/dist/'</span> <span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>，<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><ul><li><p>filename：filename的作用是控制输出资源的文件名，其形式为字符串，默认为 “bundle.js”，webpack也支持动态生成输出资源的文件名，如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry <span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        app<span class="token punctuation">:</span> <span class="token string">'./src/app.js'</span><span class="token punctuation">,</span>        vendor<span class="token punctuation">:</span> <span class="token string">'./src/vendor.js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    output <span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span> <span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>在资源输出时，上面配置的 filename中的[name]会被替换为chunk name，因此最后项目中实际生成的资源是vendor.js 与 app.js,<br>除了[name]可以指代chunk name 以外，还有其他几种模板变量可以用于filename的配置中，如表所示：</p><table><thead><tr><th>变量名称</th><th>功能描述</th></tr></thead><tbody><tr><td>[hash]</td><td>指代webpack 此次打包所有资源生成的hash</td></tr><tr><td>[chunkhash]</td><td>指代当前chunk 内容的 hash</td></tr><tr><td>[id]</td><td>指代当前chunk 的id</td></tr><tr><td>[query]</td><td>指代filename配置项中的query</td></tr></tbody></table></li><li><p>path：path 可以指定资源输出的位置，要求值必须为绝对路径，默认值为 “dist”目录。如:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span> <span class="token string">'path '</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry <span class="token punctuation">:</span> <span class="token string">'./src/app.js'</span><span class="token punctuation">,</span>    output <span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        filename <span class="token punctuation">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>        path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre></li><li><p>publicPath：publicPath是一个非常重要的配置项，并且容易与 path 相混淆。从功能上来说， path 用来指定资源的输出位置，而 publicPath 则用来指定资源的请求位置。让我们详细解释这两个定义：</p><ul><li>输出位置：打包完成后资源产生的目录，一般将其指定为工程中的 dist 目录。 </li><li>请求位置：由 JS 或 CSS 所请求的间接资源路径。页面中的资源分为两种，一种是由 HTML 页面直接请求的，比如通过 script 标签加载的 JS；另一种是由 JS 或 CSS 请求的，如异步加载的 JS、从 CSS 请求的图片字体等。publicPath 的作用就是指定这部分间接资源的请求位置。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//若当前HTML地址为https://example.com/app/index.html,异步加载的资源名为0.chunk.js</span>publicPath<span class="token punctuation">:</span> <span class="token string">""</span> <span class="token comment" spellcheck="true">// 实际路径https://example.com/app/0.chunk.js</span>publicPath<span class="token punctuation">:</span> <span class="token string">"../assets/"</span> <span class="token comment" spellcheck="true">// 实际路径https://example.com/aseets/0.chunk.js</span>publicPath<span class="token punctuation">:</span> <span class="token string">"http://cdn.com/"</span> <span class="token comment" spellcheck="true">// 实际路径http://cdn.com/0.chunk.js</span></code></pre></li></ul><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><strong>单入口应用</strong></p><p>对于单入口的场景来说，通常不必设置动态的 output.filename，直接指定输出的文件名即可。</p><p><strong>多入口应用</strong></p><p>在多入口的场景下，必然会需要模板变量来配置 filename。请看下面的例子： </p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>     entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        pageA<span class="token punctuation">:</span> <span class="token string">'./src/pageA.js'</span><span class="token punctuation">,</span>         pageB<span class="token punctuation">:</span> <span class="token string">'./src/pageB.js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>     output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>         filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span>     <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//最终输出两个文件 /dist/pageA.js 和 /dist/pageB.js，不过为了使客户端精确更新资源，一般需要使用[chunkhash]</span></code></pre><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>loader的源码结构</strong></p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">loader</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span>map<span class="token punctuation">,</span> meta<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> callback <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">handler</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span>map<span class="token punctuation">,</span>meta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">callback</span><span class="token punctuation">(</span>        <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//error</span>        result<span class="token punctuation">.</span>content<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//转换后的内容</span>        result<span class="token punctuation">.</span>map<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//转换后的source-map</span>        result<span class="token punctuation">.</span>meta<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//转换后的AST</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>引入loader</strong></p><pre class=" language-javascript"><code class="language-javascript">npm install css<span class="token operator">-</span>loadermodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span>    module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span> <span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'css-loader'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><h4 id="配置项-2"><a href="#配置项-2" class="headerlink" title="配置项"></a>配置项</h4><ul><li><p><strong>exclude</strong>、<strong>include</strong></p><p>exclude和 include同时存在时，<strong>exclude 的优先级更高</strong>。如：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    rules<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> 'css<span class="token operator">-</span>loader"<span class="token punctuation">]</span><span class="token punctuation">,</span>         exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>        include<span class="token punctuation">:</span> <span class="token regex">/node_modules\/awesome-ui/</span> <span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre></li><li><p><strong>resource</strong>、<strong>issuer</strong></p><p>resource 与 issuer可用于更加精确地确定模块规则的作用范围。在 Webpack 中，我们认为被加载模块是resource，而加载者是issuer。前面介绍的test、exclude、include本质上属于对resource的配置，而issuer的配置如下：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    rules<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token string">'css-loader'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//只有在 /src/pages/ 下的JS文件引用的CSS文件才能使这条规则失效</span>            issuer<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>                include<span class="token punctuation">:</span> <span class="token regex">/src\/pages/</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre></li><li><p><strong>enforce</strong></p><p>Webpack中的 loader 按照执行顺序可分为pre、inline、normal、post 四种类型，上面我们直接定义的 loader 都属于normal类型，inline形式官方已经不推荐使用，而pre和post则需要使用enforce来指定。如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//eslint-loader对所有js文件进行语法检测，pre则保证代码没有被其他loader修改过</span>rules<span class="token punctuation">:</span><span class="token punctuation">[</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>        enforce<span class="token punctuation">:</span> <span class="token string">'pre'</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token string">'eslint-loader'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></code></pre></li></ul><h4 id="常用loader"><a href="#常用loader" class="headerlink" title="常用loader"></a>常用loader</h4><h5 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h5><p>将ES6+的语法转化成ES5，使我们能在保证兼容性的同时使用最新的语法</p><p><strong>安装</strong></p><pre class=" language-shell"><code class="language-shell">npm install babel-loader @babel/core @babel/preset-env</code></pre><ul><li>babel-loader: 使Babel 与 Webpack 协同工作的模块。</li><li>@babel&#x2F;core: Babel编译器的核心模块。</li><li>@babel&#x2F;preset-env: Babel官方推荐的预置器，可根据用户设置目标环境。</li></ul><p><strong>配置</strong></p><pre class=" language-javascript"><code class="language-javascript">rules<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>        exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>            options<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                cacheDirectory<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                presets<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>                    <span class="token string">'env'</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        modules<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></code></pre><ul><li>cacheDirectory配置项会启用缓存机制，防止对未改变的文件进行二次编译，从而加快打包的速度。cacheDirectory可以接收一个字符串来作为缓存路径，这个值也可以为true，此时其缓存目录会指向node_modules&#x2F;.cache&#x2F;babel-loader。</li><li>由于@babel&#x2F;preset-env会将ES6 Module转化为CommonJS的形式，从而导致 Webpack 中的tree-shaking特性失效。将@babel&#x2F;preset-env的modules配置项设置为false会禁用模块语句的转化，而将ES6Module的语法交给Webpack本身处理。</li><li>babel-loader支持从**.babelrc**文件读取Babel配置，因此可以将presets和 plugins 从Webpack配置文件中提取出来，也能达到相同的效果。</li></ul><h5 id="ts-loader"><a href="#ts-loader" class="headerlink" title="ts-loader"></a>ts-loader</h5><p>ts-loader 与 babel-loader 的性质类似，它是用于连接Webpack 与 Typescript的模块。</p><p><strong>安装</strong></p><pre class=" language-shell"><code class="language-shell">npm install ts-loader</code></pre><p><strong>配置</strong></p><pre class=" language-javascript"><code class="language-javascript">rules<span class="token punctuation">:</span><span class="token punctuation">[</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.ts$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token string">'ts-loader'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></code></pre><p>需要注意的是，Typescript本身的配置并不在 ts-loader中，而是必须要放在工程目录下的 tsconfig.json中。如：</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"compileroptions"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"es5"</span><span class="token punctuation">,</span>        <span class="token property">"sourceMap"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>通过Typescript和 ts-loader，我们可以实现代码类型检查。<a href="https://github.com/TypeStrong/ts-loader">配置文档</a></p><h5 id="html-loader"><a href="#html-loader" class="headerlink" title="html-loader"></a>html-loader</h5><p>html-loader 用于将HTML文件转化为字符串并进行格式化，这使得我们可以把一个HTML片段通过JS加载进来。</p><p><strong>安装</strong></p><pre class=" language-shell"><code class="language-shell">npm install html-loader</code></pre><p><strong>配置</strong></p><pre class=" language-javascript"><code class="language-javascript">rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.html$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token string">'html-loader'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></code></pre><p><strong>使用实例</strong></p><pre class=" language-jsx"><code class="language-jsx"><span class="token comment" spellcheck="true">//header.html</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>header</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>This is a Header<span class="token punctuation">.</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>header</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">//index.js</span><span class="token keyword">import</span> headerHtml <span class="token keyword">from</span> <span class="token string">'./header.html'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//header.html将会转化为字符串，并通过document.write插人页面中。</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>headerHtml<span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><h5 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h5><p>file-loader用于打包文件类型的资源，并返回其publicPath。</p><p><strong>安装</strong></p><pre class=" language-shell"><code class="language-shell">npm install file-loader</code></pre><p><strong>配置</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpg|gif)$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> <span class="token string">'file-loader'</span><span class="token punctuation">,</span>             <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>上面我们对png、jpg、gif 这类图片资源使用file-loader,然后就可以在JS中加载图片了，如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//index.js</span><span class="token keyword">import</span> avatarImage <span class="token keyword">from</span> <span class="token string">'./avatar.jpg'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span>log <span class="token punctuation">(</span>avatarImage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// c6f482ac9a1905e1d7d22caa909371fc.jpg</span><span class="token comment" spellcheck="true">//webpack.config.js</span>output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    publicPath<span class="token punctuation">:</span> <span class="token string">'./assets'</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//index.js</span><span class="token keyword">import</span> avatarImage <span class="token keyword">from</span> <span class="token string">'./avatar.jpg'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span>log <span class="token punctuation">(</span>avatarImage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ./assets/c6f482ac9a1905e1d7d22caa909371fc.jpg</span></code></pre><p>使用Webpack打包完成后，dist 目录下会生成名为 <code>c6f482ac9al905e1d7d22caa909371fc.jpg</code>的图片文件。当配置中并没有指定output.publicPath时，打印的图片路径只是文件名，默认为文件的hash值加上文件后缀。</p><h5 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h5><p>url-loader与file-loader作用类似，唯一的不同在于用户可以设置一个文件大小的阈值，当大于该阈值时与file-loader一样返回publicPath, 而小于该阈值时则返回文件的base64形式编码。</p><p><strong>安装</strong></p><pre class=" language-shell"><code class="language-shell">npm install url-loader</code></pre><p><strong>配置</strong></p><pre class=" language-javascript"><code class="language-javascript">rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.(png|jpg|gif)$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            loader<span class="token punctuation">:</span> <span class="token string">'url-loader'</span><span class="token punctuation">,</span>            options<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                limit<span class="token punctuation">:</span> <span class="token number">10240</span><span class="token punctuation">,</span>                name<span class="token punctuation">:</span> <span class="token string">'[name].[ext]'</span><span class="token punctuation">,</span>                publicPath<span class="token punctuation">:</span> <span class="token string">'./assets-path/'</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span></code></pre><p><strong>使用示例</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> avatarImage <span class="token keyword">from</span> <span class="token string">'./avatar.jpg'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span>log <span class="token punctuation">(</span>avatarImage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//data:image/jpeg;base64,/9j/2wCEAAgGBg.....</span></code></pre><p>由于图片小于limit设置的大小，因此经过url-loader转化后得到的是base64形式的编码。</p><h4 id="自定义loader"><a href="#自定义loader" class="headerlink" title="自定义loader"></a>自定义loader</h4><ul><li><p>创建  force-strict-loader 目录，执行 <code>npm init</code></p></li><li><p>在目录下创建index.js，编写loader</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span><span class="token keyword">export</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> strict <span class="token operator">=</span> <span class="token string">'\'use strict\';\n\n'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> strict <span class="token operator">+</span> content<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>在自己的工程项目中安装 loader</p><pre class=" language-shell"><code class="language-shell">npm install <path-of-loader>/force-strict-loader</code></pre></li><li><p>配置loader</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    rules<span class="token punctuation">:</span><span class="token punctuation">[</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token string">'force-strict-loader'</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul><p>配置完后，我们自定义的 <code>force-strict-loader</code> 就会对所有JS文件添加严格模式。</p><p><strong>启用缓存</strong></p><p>当文件输人和其依赖没有发生变化时，应该让loader直接使用缓存，而不是重复进行转换的工作。在Webpack中可以使用 this.cacheable 进行控制：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// force-strict-loader/index.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheable<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cacheable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> strict <span class="token operator">=</span> <span class="token string">'\'use strict\';\n\n'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> strict <span class="token operator">+</span> content<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>通过启用缓存可以加快Webpack打包速度，并且可保证相同的输人产生相同的输出。</p><p><strong>获取options</strong></p><p>loader的配置项可通过use.options传进来，如：</p><pre class=" language-javascript"><code class="language-javascript">rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            loader<span class="token punctuation">:</span> <span class="token string">'force-strict-loader'</span><span class="token punctuation">,</span>            options<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                sourceMap<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span></code></pre><p>上面我们为force-strict-loader传人了一个配置项sourceMap，接下来我们要在loader中获取它。可以使用一个依赖库loader-utils提供的帮助函数获取：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//在控制台执行以下命令:</span>npm install loader<span class="token operator">-</span>utils<span class="token comment" spellcheck="true">// force-strict-loader/index.js</span><span class="token keyword">var</span> loaderUtils <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"loader-utils"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheable<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cacheable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取和打印options </span>    <span class="token keyword">var</span> options <span class="token operator">=</span> loaderUtils<span class="token punctuation">.</span>getOptions <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'options'</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理content</span>    <span class="token keyword">var</span> strict <span class="token operator">=</span> <span class="token string">'\'use strict\';\n\n'</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> strict <span class="token operator">+</span> content <span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>实现source-map</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// force-strict-loader/index.js</span><span class="token keyword">var</span> loaderUtils <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"loader-utils"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token keyword">var</span> SourceNode <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"source-map"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>SourceNode <span class="token punctuation">;</span><span class="token keyword">var</span> SourceMapConsumer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"source-map"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>SourceMapConsumer<span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> sourceMap<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> useStrictPrefix <span class="token operator">=</span> <span class="token string">'\'use strict\';\n\n'</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheable<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cacheable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> options <span class="token operator">=</span> loaderUtils<span class="token punctuation">.</span><span class="token function">getoptions</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支持sourceMap的版本</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>sourceMap <span class="token operator">&amp;&amp;</span> sourceMap<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> currentRequest <span class="token operator">=</span> loaderUtils<span class="token punctuation">.</span><span class="token function">getCurrentRequest</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> node <span class="token operator">=</span> SourceNode<span class="token punctuation">.</span><span class="token function">fromStringWithSourceMap</span><span class="token punctuation">(</span>            content<span class="token punctuation">,</span>            <span class="token keyword">new</span> <span class="token class-name">SourceMapConsumer</span> <span class="token punctuation">(</span>sourceMap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                node<span class="token punctuation">.</span><span class="token function">prepend</span><span class="token punctuation">(</span>useStrictPrefix<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> result <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">toStringWithSourceMap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> file<span class="token punctuation">:</span> currentRequest <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> callback <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        callback <span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span>code<span class="token punctuation">,</span> result<span class="token punctuation">.</span>map<span class="token punctuation">.</span><span class="token function">toJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不支持sourceMap的版本</span>    <span class="token keyword">return</span> useStrictPrefix <span class="token operator">+</span> content<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><ul><li>首先，在loader函数的参数中我们获取到sourceMap对象，这是由Webpack或者上一个loader传递下来的，只有当它存在时我们的loader才能进行继续处理和向下传递。</li><li>之后我们通过 <code>source-map</code> 这个库来对map进行操作，包括接收和消费之前的文件内容和sourceMap，对内容节点进行修改，最后产生新的sourceMap。</li><li>在函数返回的时候要使用 this.async 获取 callback 函数（主要是为了一次性返回多个值）。callback函数的3个参数分别是<code>抛出的错误</code>、<code>处理后的源码</code>，<code>向下一级传递的sourceMap</code>。</li></ul><h3 id="样式处理"><a href="#样式处理" class="headerlink" title="样式处理"></a>样式处理</h3><h4 id="分离样式文件"><a href="#分离样式文件" class="headerlink" title="分离样式文件"></a>分离样式文件</h4><p>在Webpack中，我们通常会独立编写 js 文件和 css 文件，并在 js 中导入 css 模块，如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//index.css</span>body<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    margin<span class="token punctuation">:</span> <span class="token number">0</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//index.js</span><span class="token keyword">import</span> <span class="token string">'./index.css'</span></code></pre><p>同时，我们一般会在 webpack.config.js 中为 css 文件配置 <code>css-loader</code>和<code>style-loader</code>，如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//webpack.config.js</span>module<span class="token punctuation">.</span><span class="token keyword">export</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'style-loader'</span><span class="token punctuation">,</span> <span class="token string">'css-loader'</span><span class="token punctuation">]</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token punctuation">]</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>配置完后，loader处理原理大致为：</p><ul><li>css-loader将index.css的样式内容转化为字符串形式，并将其作为js模块的导出内容。</li><li>style-loader 执行css-loader导出的 js 模块，获取到样式字符串，然后再以 <code>style标签</code>的形式拼接到文档中</li></ul><p>style-loader的大致原理如下：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>content<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// do nothing</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//pitch函数的执行顺序与loader处理顺序相反</span><span class="token comment" spellcheck="true">//执行顺序为 css-loader -> style-loader -> style-loader.pitch -> css-loader.pitch</span><span class="token comment" spellcheck="true">//remainingRequest参数为loader链的剩余部分，在这是css-loader(css-loader.pitch未执行)</span>module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>pitch <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>remainingRequest<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//用'!!'前缀跳过配置中的loader，避免重复执行</span>  <span class="token comment" spellcheck="true">//用loaderUtils的stringifyRequest方法将request语句中的绝对路径转为相对路径</span>  <span class="token comment" spellcheck="true">//在这里requestPath为: '!!../node_modules/css-loader/index.js!src/index.css'</span>  <span class="token comment" spellcheck="true">//前面我们说到 loader的配置有字符串形式和数组形式，其实还有一种内联(inline)形式，就是     requestPath的这种表示形式</span>  <span class="token keyword">const</span> requestPath <span class="token operator">=</span> loaderUtils<span class="token punctuation">.</span><span class="token function">stringifyRequest</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'!!'</span> <span class="token operator">+</span> remainingRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//用require语句获取css-loader返回的js模块的导出</span>  <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`    const content = require($&amp;#123;requestPath&amp;#125;)    const style = document.createElement('style');    style.innerHTML = content;    document.head.appendChild(style);  `</span></span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>从上面我们可以看出，导入的 css 模块最终会以 style标签的形式存在于我们的HTML中，因此不利于客户端对于 css 的缓存，因此我们使用<code>extract-text-webpack-plugin</code>这个插件来完成功能。</p><p><strong>extract-text-webpack-plugin</strong></p><ul><li><p>安装</p><pre class=" language-shell"><code class="language-shell">npm install extract-text-webpack-plugin</code></pre></li><li><p>配置</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    mode <span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                test<span class="token punctuation">:</span> <span class="token operator">/</span>\<span class="token punctuation">.</span>css$<span class="token operator">/</span>，                use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                        fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                         use<span class="token punctuation">:</span><span class="token string">'css-loader'</span><span class="token punctuation">,</span>                    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token function">newExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'bundle.css'</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre></li></ul><p>​我们在配置文件中并没有直接传入loader，而是使用了插件的<code>extract</code>方法包了一层。内部的<code>fallback</code>属性指定提取失败所采用的 loader，<code>use</code>属性指定在提取样式之前采用哪些 loader 进行预处理。除此之外，还要在<code>plugins</code>配置中添加该插件，并传入提取后的资源文件名。<br>​       进行打包后，所有导入的 css 文件的内容都会被提取到一个名为 <code>bundle.css</code>的文件，我们可以直接在 html 中使用它，以达到优化缓存的目的。</p><h4 id="多入口样式文件处理"><a href="#多入口样式文件处理" class="headerlink" title="多入口样式文件处理"></a>多入口样式文件处理</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//webpack.config.js</span><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> require <span class="token punctuation">(</span><span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        foo<span class="token punctuation">:</span> <span class="token string">'./src/scripts/foo.js'</span><span class="token punctuation">,</span>        bar<span class="token punctuation">:</span> <span class="token string">'./src/scripts/bar.js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>    module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                    use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'[name].css'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>打包后会在 dist 目录下生成 <code>foo.js</code>, <code>bar.js</code>,<code>foo.css</code>, <code>bar.css</code></p><h4 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h4><p><code>mini-css-extract-plugin</code>可以理解成<code>extract-text-webpack-plugin</code>的升级版，它拥有更丰富的特性和更好的性能。<br><code>mini-css-extract-plugin</code>最重要的就是它支持按需加载CSS，举个例子, a.js通过<code>import</code>函数异步加载了b.js, b.js 里面加载了style.css, 那么style. css最终只能被同步加载。但是现在mini-css-extract-plugin会单独打包出一个<br>0.css (假设使用默认配置)，这个CSS文件将由a.js通过动态插入link 标签的方式加载。<br>请看下面的例子：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// app.js</span><span class="token keyword">import</span> <span class="token string">'./style.css'</span><span class="token punctuation">;</span><span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./next-page.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'app.js&lt;br/>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// next-page.js</span><span class="token keyword">import</span> <span class="token string">'./next-page.css'</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'Next page.&lt;br/>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* style.css */</span>body <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> background<span class="token operator">-</span>color<span class="token punctuation">:</span> #eee<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* next-page.css */</span>body <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> background<span class="token operator">-</span>color<span class="token punctuation">:</span> #<span class="token number">999</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>在上面代码中，由于<code>next-page.js</code>是通过import函数<code>异步加载</code>而不是通过import关键字同步加载的，如果使用的是<code>extract-text-webpack-plugin</code>，那么我们在打包阶段只能将 <code>style.css </code>和<code>next-page.css</code>一起打包进 bundle.css 然后使用。但是如果使用的是<code>mini-css-extract-plugin</code>的话，只有 style.css 会被打包进 bundle.css，而 next-page.css 会被单独打包为 0.css（默认配置），然后在代码执行过程中，在 app.js 成功加载完 next-page.js 的同时，app.js 会将 0.css 通过 link标签的方式动态插入文档，这样就可以实现 css 的按需加载。</p><p><strong>配置</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//webpack.config.js</span><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>  output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>  module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            loader<span class="token punctuation">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>            options<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>              publicPath<span class="token punctuation">:</span> <span class="token string">'../'</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>          <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>          <span class="token string">'css-loader'</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      filename<span class="token punctuation">:</span> <span class="token string">'[name].css'</span><span class="token punctuation">,</span>      chunkFilename<span class="token punctuation">:</span> <span class="token string">'[id].css'</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  <span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>在配置上mini-css-extract-plugin与extract-text-webpack-plugin 有以下几点不同: </p><ul><li>loader 规则设置的形式不同，并且mini-css- extract-plugin支持配置publicPath，用来指定异步CSS的加载路径。</li><li>不需要设置fallback。</li><li>在plugins设置中，除了指定同步加载的CSS资源名( filename),还要指定异步加载的CSS资源名(chunkFilename)。</li></ul><h4 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h4><p>CSS Modules是近年来比较流行的一种开发模式，其理念就是把Css模块化，让CSS也拥有模块的特点，具体如下：</p><ul><li>每个CSS文件中的样式都拥有单独的作用域，不会和外界发生命名冲突。</li><li>对CSS进行依赖管理，可以通过相对路径引人CSS文件。</li><li>可以通过composes轻松复用其他CSS模块。</li></ul><p>使用CSS Modules不需要额外安装模块，只要开启css-loader中的modules配置项即可：</p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>            use<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token string">'style-loader'</span><span class="token punctuation">,</span>                loader<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                options<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    modules<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                    localIdentName<span class="token punctuation">:</span> <span class="token string">'[name]_.[local]_[hash:base64:5]'</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>这里的localldentName配置项用于指明CSS代码中的类名会如何来编译。假设源码是下面的形式：</p><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/* style.css */</span><span class="token number">.</span>title&amp;<span class="token hexcode">#123</span><span class="token punctuation">;</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#f938ab</span><span class="token punctuation">;</span>    &amp;<span class="token hexcode">#125</span><span class="token punctuation">;</span></code></pre><p><code>.title</code>经过编译后可能将成为<code>.style_ title_1CFy6</code>, 让我们依次对照上面的配置:</p><ul><li>[name]指代的是模块名，这里被替换为style。</li><li>[local] 指代的是原本的选择器标识符，这里被替换为title。</li><li>[hash:basc64:5]指代的是一个5位的hash值，这个hash值是根据模块名和标识符计算的，因此不同模块中相同的标识符也不会造成样式冲突。</li></ul><p>在使用的过程中我们还要注意在JavaScript中引入CSS的方式。之前只是直接将CSS文件引入就可以了，但使用CSS Modules时CSS文件会导出一个对象，我们需要把这个对象中的属性添加到HTML标签上。请看下面的示例：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> styles <span class="token keyword">from</span> <span class="token string">'./style.css'</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'&lt;hl class="$&amp;#123;styles.title)">My Webpack app.&lt;/h1>*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最终这个HTML中的class才能与我们编译后的CSS类名匹配上。</p><h3 id="代码分片"><a href="#代码分片" class="headerlink" title="代码分片"></a>代码分片</h3><p>​实现高性能应用其中重要的一点就是尽可能地让用户每次只加载必要的资源，优先级不太高的资源则采用延迟加载等技术渐进式地获取，这样可以保证页面的首屏速度。<br>​代码分片( code splitting)是Webpack作为打包工具所特有的一项技术, 通过这项技术我们可以把代码按照特定的形式进行拆分，使用户不必一次全部加载，而是按需加载。<br>​代码分片可以有效降低首屏加载资源的大小，但同时也会带来新的问题，比如我们应该对哪些模块进行分片、分片后的资源如何管理等，这些也是需要关注的。</p><h4 id="通过入口划分代码"><a href="#通过入口划分代码" class="headerlink" title="通过入口划分代码"></a>通过入口划分代码</h4><p>在Webpack中每个人口(entry) 都将生成一个对应的资源文件，通过入口的配置我们可以进行一些简单有效的代码拆分。<br>对于Web应用来说通常会有一些库和工具是不常变动的，可以把它们放在一个单独的入口中，由该人口产生的资源不会经常更新，因此可以有效地利用客户端缓存，让<br>用户不必在每次请求页面时都重新加载。如:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//webpack.config.js</span>entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    app<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    lib<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'lib-a'</span><span class="token punctuation">,</span> <span class="token string">'lib-b'</span><span class="token punctuation">,</span> <span class="token string">'lib-c'</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//index.html</span><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"dist/lib.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>script sre<span class="token operator">=</span><span class="token string">"dist/app.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>这种拆分方法主要适合于那些将接口绑定在全局对象上的库（如JQuery），因为业务代码中的模块无法直接引用库中的模块，二者属于不同的依赖树。<br>对于多页面应用来说，我们也可以利用入口划分的方式拆分代码。比如，为每一个页面创建一个入口，并放入只涉及该页面的代码，同时再创建一个入口来包含所有公共模块，并使每个页面都进行加载。但是这样仍会带来公共模块与业务模块处于不同依赖树的问题。另外，很多时候不是所有的页面都需要这些公共模块。比如A、B页面需要lib-a模块，C、D需要lib-b模块，通过手工的方式去配置和提取公共模块将会变得十分复杂，因此我们可以使用Webpack专门提供的插件来解决这个问题。</p><h4 id="CommonsChunkPlugin"><a href="#CommonsChunkPlugin" class="headerlink" title="CommonsChunkPlugin"></a>CommonsChunkPlugin</h4><p>CommonsChunkPlugin是 Webpack 4之前内部自带的插件( Webpack 4之后替换为了SplitChunks)。它可以将多个Chunk 中公共的部分提取出来。公共模块的提取可以为项目带来几个收益：</p><ul><li>开发过程中减少了重复模块打包，可以提升开发速度;</li><li>减小整体资源体积;</li><li>合理分片后的代码可以更有效地利用客户端缓存。</li></ul><p>假设我们当前的项目中有foo.js和bar.js两个入口文件，并且都引入了react，下面是未使用CommonsChunkPlugin 的配置：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//webpack.config.js</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        foo<span class="token punctuation">:</span> <span class="token string">'./foo.js'</span><span class="token punctuation">,</span>        bar<span class="token punctuation">:</span> <span class="token string">'./bar.js'</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        filename<span class="token punctuation">:</span> <span class="token string">"[name].js"</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// foo .js</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'foo.js'</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span>version<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment" spellcheck="true">// bar.js</span><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">'bar.js'</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span>version<span class="token punctuation">)</span> <span class="token punctuation">;</span></code></pre><p>打包后会有两个资源文件 foo.js 和 bar.js，大小都为73.1KB。</p><p>使用CommonsChunkPlugin的配置如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//webpack.config.js</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        foo<span class="token punctuation">:</span> <span class="token string">'./foo.js'</span><span class="token punctuation">,</span>        bar<span class="token punctuation">:</span> <span class="token string">'. /bar.js'</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>commonsChunkPlugin</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            name<span class="token punctuation">:</span> <span class="token string">'commons'</span><span class="token punctuation">,</span>            filename<span class="token punctuation">:</span> <span class="token string">'commons.js'</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>webpack打包后会有三个资源文件，分别是foo.js、bar.js和commons.js，foo.js和bar.js从73.1KB的大小将为不到1KB，而common.js的大小则为73KB。<br>最后，需要在页面中添加一个script标签来引入commons.js，并且注意，该JS一定要在其他JS之前引入。</p><h4 id="异步资源"><a href="#异步资源" class="headerlink" title="异步资源"></a>异步资源</h4><p>ES6规定 import 只能出现在代码开头，而webpack提供了 import函数来异步加载模块，如：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">//ES6 Modules</span><span class="token keyword">import</span> bar <span class="token keyword">from</span> <span class="token string">'./bar.js'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//webpack</span>document<span class="token punctuation">.</span><span class="token function">getElementByTagName</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./bar.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>b <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>webpack打包时将会为 bar.js 及其依赖树生成一个资源文件一般是0.js（有更多的异步资源的话序号依次递增），在点击页面时webpack会生成一个script标签（src属性为0.js）并插入到head标签中。</p><p>如果要指定异步资源的名称，需要用到webpack的特殊注释，如：</p><pre class=" language-javascript"><code class="language-javascript">document<span class="token punctuation">.</span><span class="token function">getElementByTagName</span><span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">/* webpackchunkName : "bar" */</span> <span class="token string">'./bar.js'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>b <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h3><p>压缩JavaScript</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// webpack version &lt; 4</span><span class="token keyword">const</span> webpack <span class="token operator">=</span> require <span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>optimize<span class="token punctuation">.</span>uglifyJsPlugin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// webpack >= 4</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    entry<span class="token punctuation">:</span> <span class="token string">'./app.js '</span><span class="token punctuation">,</span>    output<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    optimization<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        minimize<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>压缩CSS</p><p>压缩CSS文件的前提是使用<code>extract-text-webpack-plugin</code>或<code>mini-css-extract-plugin</code>将样式提取出来，接着使用<code>optimize-css-assets-webpack-plugin</code>来进行压缩，这个插件本质上使用的是压缩器<code>cssnano</code>，当然我们也可以通过其配置进行切换。具体请看下面的例子:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> ExtractTextPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span> <span class="token string">'extract-text-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> OptimizeCSSAssetsPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'optimize-css-assets-webpack-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span>    module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                test<span class="token punctuation">:</span> <span class="token regex">/\.css$/</span><span class="token punctuation">,</span>                use<span class="token punctuation">:</span> ExtractTextPlugin<span class="token punctuation">.</span><span class="token function">extract</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    fallback<span class="token punctuation">:</span> <span class="token string">'style-loader'</span><span class="token punctuation">,</span>use<span class="token punctuation">:</span> <span class="token string">'css-loader'</span><span class="token punctuation">,</span>                <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">,</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token punctuation">]</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">ExtractTextPlugin</span><span class="token punctuation">(</span><span class="token string">'style.css'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    optimization<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        minimizer <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">OptimizeCSSAssetsPlugin</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//生效范围，只压缩匹配到的资源</span>            assetNameRegExp<span class="token punctuation">:</span> <span class="token regex">/\.optimize\.css$/g</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//压缩处理器，默认为cssnano</span>            cssProcessor<span class="token punctuation">:</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'cssnano'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//压缩处理器的配置</span>            cssProcessorOptions<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                discardcomments<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> removeAll<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">//是否展示log</span>            canPrint <span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h3><p>HappyPack是一个通过<code>多线程</code>来提升Webpack打包速度的工具。HappyPack 可以显著地缩短打包时间。首先让我们了解一下它是如何工作的：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> HappyPack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'happypack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//...</span>    module<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                test <span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>                exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span> <span class="token punctuation">,</span>                loader <span class="token punctuation">:</span> <span class="token string">'happypack/loader?id=js'</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                test <span class="token punctuation">:</span> <span class="token regex">/\.ts$/</span><span class="token punctuation">,</span>                exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>                loader<span class="token punctuation">:</span> <span class="token string">'happypack/loader?id=ts'</span><span class="token punctuation">,</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token punctuation">]</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token keyword">new</span> <span class="token class-name">HappyPack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            id<span class="token punctuation">:</span> <span class="token string">'js'</span><span class="token punctuation">,</span>            loaders<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>                options<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//babel options</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">HappyPack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            id<span class="token punctuation">:</span> <span class="token string">'ts'</span><span class="token punctuation">,</span>            loaders<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                loader<span class="token punctuation">:</span> <span class="token string">'ts-loader'</span><span class="token punctuation">,</span>                options<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//ts options</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>    <span class="token punctuation">]</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>在使用多个HappyPack loader的同时也就意味着要插入多个HappyPack的插件，每个插件加上 id 来作为标识。同时我们也可以为每个插件设置具体不同的配置项，如使用的线程数、是否开启 debug模式等。</p><h1 id="Webpack面试题"><a href="#Webpack面试题" class="headerlink" title="Webpack面试题"></a>Webpack面试题</h1><h2 id="source-map是什么？生产环境怎么用？"><a href="#source-map是什么？生产环境怎么用？" class="headerlink" title="source map是什么？生产环境怎么用？"></a>source map是什么？生产环境怎么用？</h2><p><code>source map</code> 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。</p><p>map文件只要不打开开发者工具，浏览器是不会加载的。</p><p>线上环境一般有三种处理方案：</p><ul><li><code>hidden-source-map</code>：借助第三方错误监控平台 Sentry 使用</li><li><code>nosources-source-map</code>：只会显示具体行数以及查看源代码的错误栈。安全性比 sourcemap 高</li><li><code>sourcemap</code>：通过 nginx 设置将 .map 文件只对白名单开放(公司内网)</li></ul><p>注意：避免在生产中使用 <code>inline-</code> 和 <code>eval-</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p><h2 id="Webpack-的热更新原理"><a href="#Webpack-的热更新原理" class="headerlink" title="Webpack 的热更新原理"></a>Webpack 的热更新原理</h2><p><code>Webpack</code> 的热更新又称热替换（<code>Hot Module Replacement</code>），缩写为 <code>HMR</code>。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p><p>HMR相比于live-server的优势是可以保存状态。</p><p>HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS （webpack-dev-server）与浏览器之间维护了一个 <code>Websocket</code>，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 <code>Ajax</code> 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 <code>jsonp</code> 请求获取该chunk的增量更新。</p><p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 <code>HotModulePlugin</code> 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像<code>react-hot-loader</code> 和 <code>vue-loader</code> 都是借助这些 API 实现 HMR。</p><h2 id="Webpack构建流程简单说一下"><a href="#Webpack构建流程简单说一下" class="headerlink" title="Webpack构建流程简单说一下"></a>Webpack构建流程简单说一下</h2><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ul><li><code>初始化参数</code>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li><li><code>开始编译</code>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li><li><code>确定入口</code>：根据配置中的 entry 找出所有的入口文件</li><li><code>编译模块</code>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><code>完成模块编译</code>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li><li><code>输出资源</code>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><code>输出完成</code>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ul><p>在以上过程中，<code>Webpack</code> 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h2 id="Loader和Plugin的区别？"><a href="#Loader和Plugin的区别？" class="headerlink" title="Loader和Plugin的区别？"></a>Loader和Plugin的区别？</h2><p><code>Loader</code> 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p><p><code>Plugin</code> 就是插件，基于事件流框架 <code>Tapable</code>，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p><code>Loader</code> 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p><p><code>Plugin</code> 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3flex布局知识点</title>
      <link href="/2022/07/29/css3flex-bu-ju-zhi-shi-dian/"/>
      <url>/2022/07/29/css3flex-bu-ju-zhi-shi-dian/</url>
      
        <content type="html"><![CDATA[<h3 id="flex布局的特点"><a href="#flex布局的特点" class="headerlink" title="flex布局的特点"></a>flex布局的特点</h3><p>操作方便，布局极为简单，移动端应用很广泛</p><p>PC端浏览器支持情况较差</p><p>IE 11或更低版本，不支持或仅部分支持</p><h3 id="flex布局原理"><a href="#flex布局原理" class="headerlink" title="flex布局原理"></a>flex布局原理</h3><p>弹性布局，块级元素和行级元素都可以指定为flex布局</p><p>当父盒子设为flex布局后，子元素的float、clear和vertical-align属性将失效</p><p>原理：通过给父盒子添加flex属性，来控制子盒子的位置和排列方式</p><h3 id="父项常见属性"><a href="#父项常见属性" class="headerlink" title="父项常见属性"></a>父项常见属性</h3><p>flex-direction：设置主轴的方向</p><p>justify-content：设置主轴的子元素排列方式</p><p>flex-wrap：设置子元素是否换行</p><p>align-content:设置侧轴上的子元素的排列方式（多行）</p><p>align-item：设置侧轴上的子元素的排序方式（单行）</p><p>flex-flow：复合属性，相当于同时设置了flex-direction和flex-wrap</p><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>属性值决定主轴的方向</p><p>主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴；</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>row</td><td>默认从左到右</td></tr><tr><td>row-reverse</td><td>从右到左</td></tr><tr><td>column</td><td>从上到下</td></tr><tr><td>column-reverse</td><td>从下到上</td></tr></tbody></table><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>设置主轴上的子元素排列方式</p><p>要先确认主轴是哪个</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值 从头开始 如果主轴是x轴，则从左到右</td></tr><tr><td>flex-end</td><td>从尾部开始排序</td></tr><tr><td>center</td><td>在主轴居中对齐</td></tr><tr><td>space-around</td><td>平分剩余空间</td></tr><tr><td>space-between</td><td>先两边贴边，再平分剩余空间</td></tr></tbody></table><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>设置子元素是否换行</p><p>默认情况下，flex项目都排在一条线上，flex-wrap属性定义，flex布局默认是不换行的，如果撞不开，会缩小子元素的宽度</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>nowrap</td><td>默认值，不换行</td></tr><tr><td>wrap</td><td>换行</td></tr></tbody></table><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>设置侧轴上的子元素的排列方式（单行）</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值 从上到下</td></tr><tr><td>flex-end</td><td>从下到上</td></tr><tr><td>center</td><td>挤在一起居中</td></tr><tr><td>stretch</td><td>拉伸</td></tr></tbody></table><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>设置侧轴上的子元素的排列方式（多行）</p><p>设置子项再侧轴上的排列方式并且只能用于子项出现换行的情况，在单行下是没有效果的</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值在侧轴的头部开始排列</td></tr><tr><td>flex-end</td><td>在侧轴的尾部开始排列</td></tr><tr><td>center</td><td>在侧轴中间显示</td></tr><tr><td>space-around</td><td>子项在侧轴平分剩余空间</td></tr><tr><td>space-between</td><td>子项在侧轴先分布两头，在平分剩余空间</td></tr><tr><td>stretch</td><td>设置子元素高度平分父元素高度</td></tr></tbody></table><h5 id="align-content和align-items区别"><a href="#align-content和align-items区别" class="headerlink" title="align-content和align-items区别"></a>align-content和align-items区别</h5><p>align-items适用于单行情况下，只有上对齐、下对齐、居中和拉伸</p><p>align-content适用于多行情况下，可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值</p><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>复合属性，相当于同时设置了flex-direction和flex-wrap</p><pre><code>flex-flow：row wrap;</code></pre><h3 id="子项常见属性"><a href="#子项常见属性" class="headerlink" title="子项常见属性"></a>子项常见属性</h3><p>flex子项目占的份数</p><p>align——self控制子项自己在侧轴的排列方式</p><p>order属性定义子项的排列顺序</p><h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p>定义子项目分配剩余空间，用flex来表示占多少份数</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p> 控制子项自己在侧轴上的排列方式</p><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值是auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>定义项目的排列顺序</p><p>数值越小，排列越靠前，默认为0</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>组件高级通信</title>
      <link href="/2022/05/07/zu-jian-gao-ji-tong-xin/"/>
      <url>/2022/05/07/zu-jian-gao-ji-tong-xin/</url>
      
        <content type="html"><![CDATA[<h3 id="第一种：props"><a href="#第一种：props" class="headerlink" title="第一种：props"></a>第一种：props</h3><p>适用于的场景：父子组件通信</p><p>注意事项：如果父组件给子组件传递数据（函数），本质是子组件给父组件传递数据</p><p>如果父组件给子组件传递数据（非函数），本质是父组件给子组件传递数据</p><p>三种书写方式：</p><ol><li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p></li><li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p></li><li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p><pre class=" language-js"><code class="language-js">props<span class="token punctuation">:</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    name<span class="token punctuation">:</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    type<span class="token punctuation">:</span>String<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//类型</span>    required<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//必要性</span>    <span class="token keyword">default</span><span class="token punctuation">:</span><span class="token string">'老王'</span> <span class="token comment" spellcheck="true">//默认值</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ol><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p></blockquote><h3 id="第二种：自定义事件"><a href="#第二种：自定义事件" class="headerlink" title="第二种：自定义事件"></a>第二种：自定义事件</h3><p>适用于场景：子组件给父组件传递数据</p><p>$on与$emit</p><h3 id="第三种：全局事件总线"><a href="#第三种：全局事件总线" class="headerlink" title="第三种：全局事件总线"></a>第三种：全局事件总线</h3><p>适用于场景：万能</p><p>Vue.prototype.$bus &#x3D; this;</p><h3 id="第四种：pubsub-js，在React框架中使用比较多"><a href="#第四种：pubsub-js，在React框架中使用比较多" class="headerlink" title="第四种：pubsub-js，在React框架中使用比较多"></a>第四种：pubsub-js，在React框架中使用比较多</h3><p>适用于场景：万能</p><h3 id="第五种：Vuex"><a href="#第五种：Vuex" class="headerlink" title="第五种：Vuex"></a>第五种：Vuex</h3><p>使用场景：万能</p><h3 id="第六种：插槽"><a href="#第六种：插槽" class="headerlink" title="第六种：插槽"></a>第六种：插槽</h3><p>适用于场景：父子组件通信（标签的父子关系）</p><p>默认插槽，具名插槽，作用域插槽</p><h4 id="事件的注意事项："><a href="#事件的注意事项：" class="headerlink" title="事件的注意事项："></a>事件的注意事项：</h4><p>事件：系统事件 click、双击、鼠标系列等等</p><p>​自定义事件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>函数防抖</title>
      <link href="/2022/05/07/han-shu-fang-dou-yu-jie-liu/"/>
      <url>/2022/05/07/han-shu-fang-dou-yu-jie-liu/</url>
      
        <content type="html"><![CDATA[<p>防抖：前面的所有的触发都被取消，最后一次执行，在规定的时间之后才会被触发，也就是说如果连续快速的触发，只会执行一次(_.debounce)</p><p>节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发（_.throttle）</p><p>引入lodash插件：里面封装函数的防抖和节流业务【闭包+延迟器】</p><p>lodash函数对外暴露_函数</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript</title>
      <link href="/2022/05/07/typescript/"/>
      <url>/2022/05/07/typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h2><p>1.类型声明</p><p>类型声明是TS非常重要的一个特点</p><p>通过类型声明可以指定TS中变量（参数、形参）的类型</p><p>指定类型之后，当为变量赋值时，TS编译器会自动检查值是否复合类型声明，符合则赋值，否则报错</p><p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p><p>语法</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">let</span> a<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">;</span><span class="token keyword">let</span> a<span class="token punctuation">:</span><span class="token keyword">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">,</span>b<span class="token punctuation">:</span><span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">number</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>2.自动类型判断</p><p>TS具有自动类型判断机制</p><p>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</p><p>所以当变量的声明和赋值同时进行的话，可以省略类型声明</p><p>3.类型</p><table><thead><tr><th>类型</th><th>例子</th><th>描述</th></tr></thead><tbody><tr><td>number</td><td>1,33</td><td>任意数字</td></tr><tr><td>string</td><td>‘hi’</td><td>任意字符串</td></tr><tr><td>boolean</td><td>true,false</td><td>布尔值</td></tr><tr><td>字面量</td><td>let b:boolean:string</td><td>限制的变量的值就是该字面量的值</td></tr><tr><td>any</td><td></td><td>任意类型</td></tr><tr><td>unknown</td><td></td><td>未知的</td></tr><tr><td>void</td><td>空值（undefined）</td><td>没有值或者undefined</td></tr><tr><td>never</td><td>没有值</td><td>不能是任何值（函数体抛出异常）</td></tr><tr><td>object</td><td>{name:’孙悟空’}</td><td>任意的JS对象</td></tr><tr><td>array</td><td>[1,2,3]</td><td>任意的JS数组</td></tr><tr><td>tuple</td><td>[4,5]</td><td>元素，TS新增类型，固定长度数组</td></tr><tr><td>enum</td><td>enum{A,B}</td><td>枚举，TS中新增类型</td></tr></tbody></table><p>类型断言</p><p>语法：</p><p>1.变量 as 类型</p><p>2.&lt;类型&gt;变量</p><p>数组的类型声明</p><p>1.类型[]</p><p>2.Array&lt;类型&gt;</p><h2 id="2-编译选项"><a href="#2-编译选项" class="headerlink" title="2.编译选项"></a>2.编译选项</h2><h3 id="自动编译文件"><a href="#自动编译文件" class="headerlink" title="自动编译文件"></a>自动编译文件</h3><p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p><p>示例：</p><pre><code>  tsc xxx.ts -w</code></pre><h3 id="自动编译整个项目"><a href="#自动编译整个项目" class="headerlink" title="自动编译整个项目"></a>自动编译整个项目</h3><p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p><p><strong>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</strong></p><p>tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译</p><p>配置选项：</p><h4 id="include"><a href="#include" class="headerlink" title="include"></a><strong>include</strong></h4><ul><li>定义希望被编译文件所在的目录</li><li>默认值：[“**&#x2F;*”]</li></ul><p>示例：</p><pre><code>  &quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]</code></pre><p>上述示例中，所有src目录和tests目录下的文件都会被编译</p><h4 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><strong>exclude</strong></h4><ul><li>定义需要排除在外的目录</li><li>默认值：[“node_modules”, “bower_components”, “jspm_packages”]</li></ul><p>示例：</p><pre><code>  &quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]</code></pre><p>上述示例中，src下hello目录下的文件都不会被编译</p><h4 id="extends"><a href="#extends" class="headerlink" title="extends"></a><strong>extends</strong></h4><ul><li>定义被继承的配置文件</li></ul><p>示例：</p><pre><code>&quot;extends&quot;: &quot;./configs/base&quot;</code></pre><p>上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</p><h4 id="files"><a href="#files" class="headerlink" title="files"></a><strong>files</strong></h4><ul><li>指定被编译文件的列表，<strong>只有需要编译的文件少时才会用到</strong></li></ul><p>示例：</p><pre><code>&quot;files&quot;: [    &quot;core.ts&quot;,    &quot;sys.ts&quot;,    &quot;types.ts&quot;,    &quot;scanner.ts&quot;,    &quot;parser.ts&quot;,    &quot;utilities.ts&quot;,    &quot;binder.ts&quot;,    &quot;checker.ts&quot;,    &quot;tsc.ts&quot;  ]</code></pre><ul><li>列表中的文件都会被TS编译器所编译</li></ul><h4 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h4><ul><li>编译选项是配置文件中非常重要也比较复杂的配置选项</li><li>在compilerOptions中包含多个子选项，用来完成对编译的配置</li></ul><p>项目选项：</p><ul><li><p>target</p><ul><li><p>设置ts代码编译的目标版本</p></li><li><p>可选值：</p><ul><li>ES3（默认）、ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li></ul></li><li><p>示例：</p><ul><li><pre><code>&quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;ES6&quot;&#125;</code></pre></li></ul></li><li><p>如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</p></li></ul></li><li><p>lib</p><ul><li><p>指定代码运行时所包含的库（宿主环境）</p></li><li><p>可选值：</p><ul><li>ES5、ES6&#x2F;ES2015、ES7&#x2F;ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ……</li></ul></li><li><p>示例：</p><ul><li><pre><code>&quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;ES6&quot;,    &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],    &quot;outDir&quot;: &quot;dist&quot;,    &quot;outFile&quot;: &quot;dist/aa.js&quot;&#125;</code></pre></li></ul></li></ul></li><li><p>module</p><ul><li><p>设置编译后代码使用的模块化系统</p></li><li><p>可选值：</p><ul><li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li></ul></li><li><p>示例：</p><ul><li><pre><code>&quot;compilerOptions&quot;: &#123;    &quot;module&quot;: &quot;CommonJS&quot;&#125;</code></pre></li></ul></li></ul></li><li><p>outDir</p><ul><li><p>编译后文件的所在目录</p></li><li><p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</p></li><li><p>示例：</p><ul><li><pre><code>&quot;compilerOptions&quot;: &#123;    &quot;outDir&quot;: &quot;dist&quot;&#125;</code></pre></li><li><p>设置后编译后的js文件将会生成到dist目录</p></li></ul></li></ul></li><li><p>outFile</p><ul><li><p>将所有的文件编译为一个js文件</p></li><li><p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p></li><li><p>示例：</p><ul><li><pre><code>&quot;compilerOptions&quot;: &#123;    &quot;outFile&quot;: &quot;dist/app.js&quot;&#125;</code></pre></li></ul></li></ul></li><li><p>rootDir</p><ul><li><p>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</p></li><li><p>示例：</p><ul><li><pre><code>&quot;compilerOptions&quot;: &#123;    &quot;rootDir&quot;: &quot;./src&quot;&#125;</code></pre></li></ul></li></ul></li><li><p>allowJs</p><ul><li>是否对js文件编译</li></ul></li><li><p>checkJs</p><ul><li><p>是否对js文件进行检查</p></li><li><p>示例：</p><ul><li><pre><code>&quot;compilerOptions&quot;: &#123;    &quot;allowJs&quot;: true,    &quot;checkJs&quot;: true&#125;</code></pre></li></ul></li></ul></li><li><p>removeComments</p><ul><li>是否删除注释</li><li>默认值：false</li></ul></li><li><p>noEmit</p><ul><li>不对代码进行编译</li><li>默认值：false</li></ul></li><li><p>sourceMap</p><ul><li>是否生成sourceMap</li><li>默认值：false</li></ul></li><li><p>严格检查</p><ul><li>strict<ul><li>启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</li></ul></li><li>alwaysStrict<ul><li>总是以严格模式对代码进行编译</li></ul></li><li>noImplicitAny<ul><li>禁止隐式的any类型</li></ul></li><li>noImplicitThis<ul><li>禁止类型不明确的this</li></ul></li><li>strictBindCallApply<ul><li>严格检查bind、call和apply的参数列表</li></ul></li><li>strictFunctionTypes<ul><li>严格检查函数的类型</li></ul></li><li>strictNullChecks<ul><li>严格的空值检查</li></ul></li><li>strictPropertyInitialization<ul><li>严格检查属性是否初始化</li></ul></li></ul></li><li><p>额外检查</p><ul><li>noFallthroughCasesInSwitch<ul><li>检查switch语句包含正确的break</li></ul></li><li>noImplicitReturns<ul><li>检查函数没有隐式的返回值</li></ul></li><li>noUnusedLocals<ul><li>检查未使用的局部变量</li></ul></li><li>noUnusedParameters<ul><li>检查未使用的参数</li></ul></li></ul></li><li><p>高级</p><ul><li>allowUnreachableCode<ul><li>检查不可达代码</li><li>可选值：<ul><li>true，忽略不可达代码</li><li>false，不可达代码将引起错误</li></ul></li></ul></li><li>noEmitOnError<ul><li>有错误的情况下不进行编译</li><li>默认值：false</li></ul></li></ul></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>要想面向对象，操作对象，首先便要拥有对象；</p><p>要创建对象，必须要先定义类，所谓的类可以理解为对象的模型；</p><p>程序中可以根据类创建指定类型的对象；</p><p>举例来说：</p><p>可以通过Person类来创建人的对象，通过Dog类创建狗的对象，不同的类可以用来创建不同的对象；</p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><pre><code>class 类名 &#123;    属性名: 类型;        constructor(参数: 类型)&#123;        this.属性名 = 参数;    &#125;        方法名()&#123;        ....    &#125;&#125;</code></pre><p>示例：</p><pre><code>    class Person&#123;        name: string;        age: number;            constructor(name: string, age: number)&#123;            this.name = name;            this.age = age;        &#125;            sayHello()&#123;            console.log(`大家好，我是$&#123;this.name&#125;`);        &#125;    &#125;</code></pre><p>使用类：</p><pre><code>const p = new Person(&#39;孙悟空&#39;, 18);p.sayHello();</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>可以使用<code>constructor</code>定义一个构造器方法；</p><blockquote><p><strong>注1：在TS中只能有一个构造器方法！</strong></p></blockquote><p>例如：</p><pre><code>class C&#123;    name: string;    age: number    constructor(name: string, age: number) &#123;        this.name = name;        this.age = age;    &#125;&#125;</code></pre><p>同时也可以直接将属性定义在构造函数中：</p><pre><code>class C &#123;    constructor(public name: string, public age: number) &#123;    &#125;&#125;</code></pre><p>上面两种定义方法是完全相同的！</p><p><strong>注2：子类继承父类时，必须调用父类的构造方法（如果子类中也定义了构造方法）！</strong></p><p>例如：</p><pre><code>class A &#123;    protected num: number;    constructor(num: number) &#123;        this.num = num;    &#125;&#125;class X extends A &#123;    protected name: string;    constructor(num: number, name: string) &#123;        super(num);        this.name = name;    &#125;&#125;</code></pre><p>如果在X类中不调用<code>super</code>将会报错！</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p><p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p><ul><li>静态属性（static）：<ul><li>声明为static的属性或方法不再属于实例，而是属于类的属性；</li></ul></li><li>只读属性（readonly）：<ul><li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</li></ul></li><li>TS中属性具有三种修饰符：<ul><li>public（默认值），可以在类、子类和对象中修改</li><li>protected ，可以在类、子类中修改</li><li>private ，可以在类中修改</li></ul></li></ul><p>示例：</p><p>public：</p><pre><code>class Person&#123;    public name: string; // 写或什么都不写都是public    public age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以在类中修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#39;孙悟空&#39;, 18);p.name = &#39;猪八戒&#39;;// 可以通过对象修改</code></pre><p>protected：</p><pre><code>class Person&#123;    protected name: string;    protected age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中可以修改    &#125;&#125;const p = new Person(&#39;孙悟空&#39;, 18);p.name = &#39;猪八戒&#39;;// 不能修改</code></pre><p>private：</p><pre><code>class Person&#123;    private name: string;    private age: number;    constructor(name: string, age: number)&#123;        this.name = name; // 可以修改        this.age = age;    &#125;    sayHello()&#123;        console.log(`大家好，我是$&#123;this.name&#125;`);    &#125;&#125;class Employee extends Person&#123;    constructor(name: string, age: number)&#123;        super(name, age);        this.name = name; //子类中不能修改    &#125;&#125;const p = new Person(&#39;孙悟空&#39;, 18);p.name = &#39;猪八戒&#39;;// 不能修改</code></pre><h3 id="属性存取器"><a href="#属性存取器" class="headerlink" title="属性存取器"></a>属性存取器</h3><p>对于一些不希望被任意修改的属性，可以将其设置为private</p><p>直接将其设置为private将导致无法再通过对象修改其中的属性</p><p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p><p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p><p>示例：</p><pre><code>class Person&#123;    private _name: string;    constructor(name: string)&#123;        this._name = name;    &#125;    get name()&#123;        return this._name;    &#125;    set name(name: string)&#123;        this._name = name;    &#125;&#125;const p1 = new Person(&#39;孙悟空&#39;);// 实际通过调用getter方法读取name属性console.log(p1.name);// 实际通过调用setter方法修改name属性 p1.name = &#39;猪八戒&#39;; </code></pre><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p><p>静态属性（方法）使用static开头</p><p>示例：</p><pre><code>class Tools&#123;    static PI = 3.1415926;        static sum(num1: number, num2: number)&#123;        return num1 + num2    &#125;&#125;console.log(Tools.PI);console.log(Tools.sum(123, 456));</code></pre><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>在类中，使用this表示当前对象</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承时面向对象中的又一个特性</p><p>通过继承可以将其他类中的属性和方法引入到当前类中</p><p>示例：</p><pre><code>class Animal&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;&#125;class Dog extends Animal&#123;    bark()&#123;        console.log(`$&#123;this.name&#125;在汪汪叫！`);    &#125;&#125;const dog = new Dog(&#39;旺财&#39;, 4);dog.bark();</code></pre><p>通过继承可以在不修改类的情况下完成对类的扩展</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</p><p>示例：</p><pre><code>class Animal&#123;    name: string;    age: number;    constructor(name: string, age: number)&#123;        this.name = name;        this.age = age;    &#125;    run()&#123;        console.log(`父类中的run方法！`);    &#125;&#125;class Dog extends Animal&#123;    bark()&#123;        console.log(`$&#123;this.name&#125;在汪汪叫！`);    &#125;    run()&#123;        console.log(`子类中的run方法，会重写父类中的run方法！`);    &#125;&#125;const dog = new Dog(&#39;旺财&#39;, 4);dog.bark();</code></pre><p><strong>在子类中可以使用super来完成对父类的引用</strong></p><h3 id="抽象类（abstract-class）"><a href="#抽象类（abstract-class）" class="headerlink" title="抽象类（abstract class）"></a>抽象类（abstract class）</h3><p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p><pre><code>abstract class Animal&#123;  abstract run(): void;  bark()&#123;      console.log(&#39;动物在叫~&#39;);  &#125;&#125;class Dog extends Animals&#123;  run()&#123;      console.log(&#39;狗在跑~&#39;);  &#125;&#125;</code></pre><p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现;</p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口的作用类似于抽象类，不同点在于：接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法；</p><p>接口主要负责定义一个类的结构，接口可以去限制一个对象的接口：对象只有包含接口中定义的所有属性和方法时才能匹配接口；</p><p>同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性；</p><p>示例（检查对象类型）：</p><pre><code>interface Person&#123;    name: string;    sayHello():void;&#125;function fn(per: Person)&#123;    per.sayHello();&#125;fn(&#123;name:&#39;孙悟空&#39;, sayHello() &#123;console.log(`Hello, 我是 $&#123;this.name&#125;`)&#125;&#125;);</code></pre><p>示例（实现）：</p><pre><code>interface Person&#123;   name: string;   sayHello():void;&#125;class Student implements Person&#123;   constructor(public name: string) &#123;   &#125;   sayHello() &#123;       console.log(&#39;大家好，我是&#39;+this.name);   &#125;&#125;</code></pre><h2 id="泛型（Generic）"><a href="#泛型（Generic）" class="headerlink" title="泛型（Generic）"></a>泛型（Generic）</h2><p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定）；</p><p>此时泛型便能够发挥作用；</p><p>举个例子：</p><pre><code>function test(arg: any): any&#123;    return arg;&#125;</code></pre><p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的；</p><p>由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的：</p><p>首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型；</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><h4 id="创建泛型函数"><a href="#创建泛型函数" class="headerlink" title="创建泛型函数"></a>创建泛型函数</h4><pre><code>function test&lt;T&gt;(arg: T): T&#123;    return arg;&#125;</code></pre><p>这里的<code>&lt;T&gt;</code>就是泛型；</p><p>T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型；</p><p>所以泛型其实很好理解，就表示某个类型；</p><p>那么如何使用上边的函数呢？</p><h4 id="使用泛型函数"><a href="#使用泛型函数" class="headerlink" title="使用泛型函数"></a>使用泛型函数</h4><h5 id="方式一（直接使用）："><a href="#方式一（直接使用）：" class="headerlink" title="方式一（直接使用）："></a>方式一（直接使用）：</h5><pre><code>test(10)</code></pre><p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p><h5 id="方式二（指定类型）："><a href="#方式二（指定类型）：" class="headerlink" title="方式二（指定类型）："></a>方式二（指定类型）：</h5><pre><code>test&lt;number&gt;(10)</code></pre><p>也可以在函数后手动指定泛型；</p><h4 id="函数中声明多个泛型"><a href="#函数中声明多个泛型" class="headerlink" title="函数中声明多个泛型"></a>函数中声明多个泛型</h4><p>可以同时指定多个泛型，泛型间使用逗号隔开：</p><pre><code>function test&lt;T, K&gt;(a: T, b: K): K&#123;  return b;&#125;test&lt;number, string&gt;(10, &quot;hello&quot;);</code></pre><p>使用泛型时，完全可以将泛型当成是一个普通的类去使用；</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>类中同样可以使用泛型：</p><pre><code>class MyClass&lt;T&gt;&#123;  prop: T;  constructor(prop: T)&#123;      this.prop = prop;  &#125;&#125;</code></pre><h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><p>除此之外，也可以对泛型的范围进行约束</p><pre><code>interface MyInter&#123;  length: number;&#125;function test&lt;T extends MyInter&gt;(arg: T): number&#123;  return arg.length;&#125;</code></pre><p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="/2022/05/07/promise/"/>
      <url>/2022/05/07/promise/</url>
      
        <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>1.抽象表达</p><p>Promise是一门新的技术（ES6规范）</p><p>Promise是JS中进行异步编程的新解决方案</p><p>2.具体表达</p><p>从语法上说，Promise是一个构造函数</p><p>从功能上说，Promise对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值</p><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><p>fs 文件操作</p><pre><code>require(&#39;fs&#39;).readFile(&#39;./index.html&#39;,(err,data)=&gt;&#123;&#125;)</code></pre><p>数据库操作</p><p>AJAX</p><pre><code>$.get(&#39;/server&#39;,(data)=&gt;&#123;&#125;)</code></pre><p>定时器</p><pre><code>setTimeout(()=&gt;&#123;&#125;,2000)</code></pre><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.指定回调函数的方式更加灵活</p><p>2.支持链式调用，可以解决回调地狱问题</p><h4 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h4><p>定义：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p><p>缺点：1.不便于阅读2.不便于异常处理</p><p>解决方案：promise链式调用</p><h3 id="Promise的工作流程"><a href="#Promise的工作流程" class="headerlink" title="Promise的工作流程"></a>Promise的工作流程</h3><p><img src="C:\Users\Win10\Desktop\前端笔记\微信图片_20220306193701.png" alt="微信图片_20220306193701"></p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>1.Promise构造函数：Promise(excutor){}</p><p>​(1) executor函数：执行器 (resolve,reject)&#x3D;&gt;{}</p><p>​(2) resolve函数：内部定义成功时我们调用的函数 value&#x3D;&gt;{}</p><p>​(3) reject函数：内部定义失败时我们调用的函数reason&#x3D;&gt;{}</p><p>说明：executor会在Promise内部立即同步调用，异步操作在执行器中执行</p><p>2.Promise.prototype.then方法:(onResolved,onRejected) &#x3D;&gt;{}</p><p>​(1) onResolved函数：成功的回调函数 (value)&#x3D;&gt;{}</p><p>​(2) onRejected函数：失败的回调函数(reason)&#x3D;&gt;{}</p><p>说明：无论是成功的回调还是失败的回调，返回的结果是一个新的promise对象</p><p>3.Promise.prototype.catch方法：(onRejected) &#x3D;&gt;{}</p><p>​(1) onRejected函数：失败的回调函数(reason)&#x3D;&gt;{}</p><p>4.Promise.resolve方法：(value)&#x3D;&gt;{}</p><p>​(1) value:成功的数据或promise对象</p><p>说明：返回一个成功&#x2F;失败的promise对象</p><p>如果传入的参数为非Promise类型的对象，则返回的结果为成功的promise对象</p><p>如果传入的参数为Promise对象，则参数的结果决定了resolve的结果</p><p>5.Promise.reject方法:(reason)&#x3D;&gt;{}</p><pre><code> (1) reason:失败的原因</code></pre><p>说明：返回一个失败的promise对象，传入什么，失败的结果就是什么</p><p>6.Promise.all方法：(promises)&#x3D;&gt;{}</p><p>​(1) promises:包含n个promise的数组</p><p>说明：返回一个新的promise，只有所有的pr下·omise都成功才成功，只要有一个失败了就直接失败了</p><p>7.Promise.race方法：(promises)&#x3D;&gt;{}</p><p>​(1) promises：包含n个promise的数组</p><p>说明：返回一个新的promise，第一个完成的promise的结果状态就是最终的结果状态 </p><h3 id="Promise的几个关键问题"><a href="#Promise的几个关键问题" class="headerlink" title="Promise的几个关键问题"></a>Promise的几个关键问题</h3><p>1.如何改变promise的状态？</p><p>​(1) resolve(value): 如果当前是pending就会变为resolved</p><p>​(2) reject(reason): 如果当前是pending就会变为rejected</p><p>​(3) 抛出异常：如果当前是pending就会变为rejected</p><p>2.一个promise指定多个成功&#x2F;失败的回调，都会gai’bia调用吗？</p><p>​当promise改变为对应状态时都会调用</p><p>3.改变promise状态和指定回调函数谁先谁后？</p><p>​(1) 都有可能，正常情况下是先指定回调在改变状态，但也可以先改变状态再指定回调</p><p>​(2) 如何先改变状态在指定回调？</p><p>​①在执行器中直接调用resolve()&#x2F;reject()</p><p>​②延迟更长的时间才调用then()</p><p>​(3) 什么时候才能得到数据？<br>​①如果先指定回调，那当状态发生改变时，回调函数就会调用，得到数据</p><p>​指定回调-状态改变-执行回调</p><p>​②如果先改变状态，那当指定回调时，回调函数就会调用，得到数据</p><p>​状态改变-制定并执行回调</p><p>4.promise.then() 返回的新的promise的结果状态由什么决定</p><p>​(1) 简单表达：由then()指定的回调函数执行的结果决定</p><p>​(1) 详细表达：</p><p>​①如果抛出异常，新的promise变为rejected，reason为抛出的异常</p><p>​②如果返回的是非promise的任意值，新promise变为resolved，vaule为返回的值</p><p>​③如果返回的是另一个新promise，此promise的结果就会成为新promise的结果</p><p>5.promise异常穿透</p><p>​(1) 当使用promise的then链式调用时，可以在最后指定失败的回调</p><p>​(2) 前面任何操作出了异常，都会传到最后失败的回调中处理</p><p>6.中断promise链</p><p>​(1) 当使用promise的then链式调用时，在中间间断，不再调用后面的回调函数</p><p>​(2) 方法：在回调函数中返回一个pendding状态的promise对象</p><h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h3><p>1.函数的返回值为promise对象</p><p>2.promise对象的结果由async函数执行的返回值决定</p><h3 id="await表达式"><a href="#await表达式" class="headerlink" title="await表达式"></a>await表达式</h3><p>1.await右侧的表达式一般为promise对象，但也可以是其它的值</p><p>2.如果表达式是promise对象，await返回的是promise成功的值</p><p>3.如果表达式是其他值，直接将此值作为await的返回值</p><p>注意：</p><p>1.await必须写在async函数中，但async函数中可以没有await</p><p>2.如果await的promise失败了，就会抛出异常，需要通过try…catch捕获处理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2022/05/07/mongodb/"/>
      <url>/2022/05/07/mongodb/</url>
      
        <content type="html"><![CDATA[<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><p>show dbs &#x2F; show databases显示当前的数据库</p><p>use 数据库名 进入到指定的数据库</p><p>db 表示当前所处的数据库</p><p>show collectons 显示数据库中所有的集合</p><h2 id="数据库的CRUD操作"><a href="#数据库的CRUD操作" class="headerlink" title="数据库的CRUD操作"></a>数据库的CRUD操作</h2><p>db.<collection>.insert(doc)向集合中插入一个文档</p><p>例子：向test数据库中的，stuts集合中插入一个新的学生对象</p><p><code>db.stuts.insert(&#123;name:&quot;孙悟空&quot;,age:18,gender:&quot;男&quot;&#125;)</code></p><p>当我们向集合中插入文档时，如果没有给文档指定id属性，数据库会自动添加id属性用来作为文档的唯一标识</p><p>db.<collection>.insertOne() 插入一个文档数据</p><p>db.<collection>.insertMany() 插入多个文档数据，传的是数组</p><p>db.<collection>.find() 查询当前集合中的所有文档，返回的是一个数组，可以加索引</p><p>db.<collection>.find()中可以接受一个对象作为参数条件</p><p>{}表示查询集合中所有的文档</p><p>{属性:值}查询属性是指定值的文档 </p><p>db.<collection>.findOne() 查询集合中符合条件的第一个文档，返回的是一个对象</p><p>db.<collection>.find({}).count();</p><p>db.<collection>.update(查询条件，新对象，[配置项])默认情况下会使用新对象来替代旧对象，且只会修改一个</p><p>如果需要修改指定的属性，而不是替换需要使用”修改操作符”来完成修改</p><p>$set 可以用来修改文档中的指定属性</p><p><code>db.stuts.updata(&#123;&quot;name&quot;:&quot;孙悟空&quot;&#125;,&#123;$set:&#123;gender:&quot;男&quot;,address:&quot;流沙河&quot;&#125;&#125;)</code></p><p>$unset 可以用来删除文档的指定属性</p><p>$push 用于向数组中添加一个新的元素</p><p>$addToSet 向数组中添加一个新元素，当数组中有这个元素时，不会添加</p><p>db.<collection>.updateMany()同时修改多个符合条件的文档</p><p>db.<collection>.updateOne() 修改第一个符合条件的文档</p><p>db.<collection>.replaceOne() 替换一个文档</p><p>db.<collection>.remove() 删除符合条件的所有文档，传递条件的方式和find()一样</p><p><code>db.stuts.remove(&#123;age:18&#125;)</code></p><p>如果remove()第二个参数传递一个true，则只会删除一个</p><p><code>db.stuts.remove(&#123;age:28&#125;,true)</code></p><p>db.<collection>.deleteOne() </p><p>db.<collection>.deleteMany() </p><p>db.<collection>.drop() 删除集合</p><p>db.dropDatabase() 删除数据库</p><p>在MongoDB中，当一个文档的属性值是一个文档时，我们称这个文档叫做内嵌文档</p><p>MongoDB支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档可以通过 . 的形式来匹配，且属性名必须使用引号</p><p>向numbers中插入20000条数据</p><pre><code>var arr=[]for(var i = 1;i &lt; 20000;i++)&#123;​arr.push(&#123;num:i&#125;);&#125;db.numbers.insert(arr)</code></pre><p>查询numbers中num大于5000的文档</p><p><code>db.numbers.find(&#123;num:&#123;$gt:500&#125;&#125;)</code></p><p>查询numbers集合中的前10条数据</p><p><code>db.numbers.find().limit(10)</code></p><p>limit()设置显示数据的上限</p><p>skip()用于跳过指定数量的数据</p><p>查询numbers集合中的第21到30条数据</p><p><code>db.numbers.find().skip(10).limit(10)</code></p><h2 id="文档之间的关系"><a href="#文档之间的关系" class="headerlink" title="文档之间的关系"></a>文档之间的关系</h2><p>一对一</p><p>在MongoDB，可以通过内嵌文档的形式来体现出一对一的关系</p><p>夫妻（一个丈夫对应一个妻子）</p><p>一对多 &#x2F; 多对一 父母-孩子用户-订单 </p><p>在MongoDB，也可以通过内嵌文档的形式来体现出一对多或者多对一的关系</p><p>多对多老师-学生 </p><h2 id="sort和投影"><a href="#sort和投影" class="headerlink" title="sort和投影"></a>sort和投影</h2><p>查询文档时，默认情况下是按照_id的值进行排序（升序）</p><p>sort()可以指定文档的排序规则,sort()需要传递一个对象来指定排序规则  1表示升序 -1表示降序</p><p><code>dp.emp.find(&#123;&#125;).sort(&#123;sal:1&#125;)</code></p><p>在查询时，可以在第二个参数的位置来设置查询结果的 投影</p><p><code>dp.emp.find(&#123;&#125;,&#123;ename:1&#125;)</code> 只显示ename属性，默认还有_id属性</p><h2 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h2><p>Mongoose是一个对象文档模型（ODM）库，它对Node原生的MongoDB模块进行了进一步的优化封装，并提供了更多的功能</p><p>好处：</p><p>可以为文档创建一个模式结构(Schema)</p><p>可以对模型中的对象&#x2F;文档进行验证</p><p>数据可以通过类型转换转换为对象模型</p><p>可以使用中间件来应用业务逻辑挂钩</p><p>比Node原生的MongoDB驱动更容易</p><p>为我们提供了几个新的对象</p><p>Schema（模式对象）定义约束了数据库中的文档结构</p><p>Model 该对象作为集合中的所有文档的表示，相当于MongoDB数据库中的集合collection</p><p>通过Model查询的结果都是document</p><p>Document 表示集合中的具体文档，相当于集合中的一个具体的文档</p><p><code>Model.create(doc(s),[callback])</code> 用来创建一个或多个文档添加到数据库中</p><p><code>Model.find(conditions,[projection],[options],[callback])</code>查询所有符合条件的文档</p><p><code>Model.findById(id,[projection],[options],[callback])</code> 根据文档的id属性查询文档</p><p><code>Model.findOne(conditions,[projection],[options],[callback]) </code>查询符合条件的第一个文档</p><p>conditions 查询的条件</p><p>projection 投影</p><p>options 查询选项</p><p>callback 回调函数，必须传</p><p><code>Model.update(conditions,doc,[options],[callback])</code></p><p><code>Model.updateMany(conditions,doc,[options],[callback])</code></p><p><code>Model.updateOne(conditions,doc,[options],[callback])</code></p><p>doc 修改后的对象</p><p><code>Model.replaceOne(conditions,doc,[options],[callback])</code></p><p><code>Model.remove(conditions,[callback])</code></p><p><code>Model.deleteOne(conditions,[callback])</code></p><p><code>Model.deleteMany(conditions,[callback])</code></p><p><code>Model.count(conditions,[callback])</code>  统计文档的数量</p><p>document的方法</p><p><code>doc.save([options],[fn])</code> 需要注意，doc是model的实例，save的方法是给model的实例调用的</p><p><code>update(update,[options],[callback])</code></p><p><code>remove([callback])</code></p><p><code>doc.toJSON()</code>  </p><p><code>doc.toObject</code>  将Document对象转换为一个普通的JS对象，转换之后，doc的方法都用不了了</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
